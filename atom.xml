<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim-ao</title>
  <subtitle>Just Do It!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-23T09:53:27.833Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tim-ao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于JS中this知识点的总结</title>
    <link href="http://yoursite.com/%E5%85%B3%E4%BA%8EJS%E4%B8%ADthis%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/关于JS中this知识点的总结/</id>
    <published>2018-04-23T09:24:51.000Z</published>
    <updated>2018-04-23T09:53:27.833Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3>关于JS中this知识点的总结</h3><p></p>
<p></p><h5> 在闭包中使用 <strong>this</strong> 对象以及 <strong>this</strong> 指向问题</h5><p></p>
<blockquote>
<p>在闭包中使用 <strong>this</strong> 对象可能会导致以一些问题。我们知道 <strong>this</strong> 对象是基于函数的执行环境绑定的换句话说也就意味着  <strong>this始终指向被调用的对象</strong>，当this在全局函数中被调用，this指向window对象，当在匿名函数中一般情况下this指向window， 但如通过 <strong>apply</strong>，<strong>call</strong>改变函数的执行环境的情况下，this的指向会发生改变 。<br>—— 《JavaScript高级程序设计》</p>
</blockquote>
<p></p><h5>常见的几种关于this的案例<h5><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//&lt;1&gt;</div><div class="line">   var name = &apos;The Window&apos;;</div><div class="line">   var object = &#123;</div><div class="line">        name: &apos;My Object&apos;,</div><div class="line">        getNameFunc: function() &#123;</div><div class="line">           return function() &#123;</div><div class="line">              return this.name</div><div class="line">          &#125;    </div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(object.getNameFunc());   //&apos;The Window&apos;</div></pre></td></tr></table></figure><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//&lt;2&gt;</div><div class="line">   var name = &apos;The Window&apos;;</div><div class="line">   var object = &#123;</div><div class="line">        name: &apos;My Object&apos;,</div><div class="line">        getNameFunc: function() &#123;</div><div class="line">           var that = this;</div><div class="line">           return function() &#123;</div><div class="line">              return that.name</div><div class="line">          &#125;    </div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(object.getNameFunc());   </div><div class="line">    //&apos;My Window&apos; 在声明匿名函数之前就已经把this指向object的变量保存到了that里面</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//&lt;3&gt;</div><div class="line">   var name = &apos;The Window&apos;;</div><div class="line">   var object = &#123;</div><div class="line">        name: &apos;My Object&apos;,</div><div class="line">        getNameFunc: function() &#123;</div><div class="line">           return this.name</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(object.getNameFunc());   //&apos;My Object&apos;</div><div class="line">    console.log((object.getNameFunc)());   //&apos;My Object&apos;</div><div class="line">    console.log((object.getNameFunc = object.getNameFunc)());   //&apos;The Window&apos; 先执行赋值表达式，返回函数本身，再调用执行后的结果，此时this不再维持</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>改变this指向的几种情况的栗子</strong> ——《选自阮一峰JavaScript标准参考教程》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;//第一种：</div><div class="line">&gt;(obj.foo = obj.foo)()  //window </div><div class="line">&gt;//第二种：</div><div class="line">&gt;(false || function()&#123;</div><div class="line">&gt;    console.log(this)</div><div class="line">&gt;&#125;)() //window</div><div class="line">&gt;//第三种：</div><div class="line">&gt;(1, obj.foo)()   //window</div><div class="line"></div><div class="line">&gt;可以这么理解：在JavaScript引擎内部，obj，obj.foo是两个内存地址，暂且称之为内存地址一，内存地址二，在obj.foo()这么调用时相当于将地址二放在地址一得环境中执行，this指向obj，但上面三种情况是直接将地址二拿出来执行而并非在地址一种，因此都指向window对象</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//&lt;4&gt;在网页编程中的一个栗子 ——《选自阮一峰JavaScript标准参考教程》</div><div class="line">   &lt;input type=&quot;text&quot; name=&quot;age&quot; size=&quot;3&quot; onChange=&quot;validate(this, 18, 99)&quot;</div><div class="line">   &lt;script&gt;</div><div class="line">      function validate(obj, lowVal, hiVal) &#123;</div><div class="line">        if(obj.lowVal &lt; lowVal || obj.hiVal &gt; hiVal) &#123;</div><div class="line">        console.log(&quot;Invalid Value!&quot;)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">   &lt;/script&gt;</div><div class="line">   //验证了this的指向是动态的</div></pre></td></tr></table></figure>
<p></p><h5>this的多层级问题</h5><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">   p: &apos;Hello&apos;,</div><div class="line">   b: &#123;</div><div class="line">      m: function() &#123;</div><div class="line">         console.log(this.p)</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;;</div><div class="line">   a.b.m()  //undefind  a.b.m方法在a对象的第二层，内部的this指向a.b而不是a</div><div class="line">   </div><div class="line">//将上述方法解构</div><div class="line"></div><div class="line">var b: &#123;</div><div class="line">  m: function() &#123;</div><div class="line">     console.log(this.p);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">var a: &#123;</div><div class="line">   p: &apos;Hello&apos;,</div><div class="line">   b: b</div><div class="line">&#125;</div><div class="line">(a.b).m()  &lt;=&gt;  b.m()</div><div class="line"></div><div class="line">//如要达到预期结果则应该这样改写</div><div class="line">var a = &#123;</div><div class="line">   b: &#123;</div><div class="line">      m: function() &#123;</div><div class="line">         console.log(this.p)</div><div class="line">         &#125;</div><div class="line">      p: &apos;Hello&apos;,</div><div class="line">      &#125;</div><div class="line">   &#125;;</div><div class="line">   var hello = a.b.m;</div><div class="line">   hello()  //  undefinded</div><div class="line">   var hello = a.b;</div><div class="line">   hello.m() //  &apos;Hello&apos;</div><div class="line">   </div><div class="line">//m为多层内部的一个方法，为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象，为了避免这个问题，可以将方法m所在的对象赋值给变量hello,这样调用this指向就会变 </div><div class="line"></div><div class="line">在使用严格模式(&apos;use strict&apos;)下当this指向全局对象会报Cannot read property or function 等错误</div></pre></td></tr></table></figure><p></p>
<p></p><h5>数组中处理this的方法</h5><p></p>
<p></p><p>数组的map，forEach方法提供函数作为参数，这个函数内部不应该使用this</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">   v: &apos;hello&apos;,</div><div class="line">   p: [&apos;a1&apos;, &apos;a2&apos;],</div><div class="line">   f: function f() &#123;</div><div class="line">      this.p.forEach(function()&#123;</div><div class="line">         console.log(this.v + &apos; &apos; + item)</div><div class="line">      &#125;)</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">o.f();</div><div class="line">//undefined a1</div><div class="line">//undefined a2</div><div class="line"></div><div class="line">解决方案一</div><div class="line">var o = &#123;</div><div class="line">   v: &apos;hello&apos;,</div><div class="line">   p: [&apos;a1&apos;, &apos;a2&apos;],</div><div class="line">   f: function f() &#123;</div><div class="line">      var that = this;</div><div class="line">      that.p.forEach(function()&#123;</div><div class="line">         console.log(this.v + &apos; &apos; + item)</div><div class="line">      &#125;)</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">o.f();</div><div class="line">//hello a1</div><div class="line">//hello a2</div><div class="line"></div><div class="line">解决方案二</div><div class="line">var o = &#123;</div><div class="line">   v: &apos;hello&apos;,</div><div class="line">   p: [&apos;a1&apos;, &apos;a2&apos;],</div><div class="line">   f: function f() &#123;</div><div class="line">      this.p.forEach(function(item)&#123;</div><div class="line">         console.log(this.v + &apos; &apos; + item)</div><div class="line">      &#125;, this)  //传入第二参数this，其作用是固定函数的运行环境</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">o.f();</div><div class="line">//hello a1</div><div class="line">//hello a2</div></pre></td></tr></table></figure><p></p>
<p></p><h5>绑定this的方法</h5><p></p>
<blockquote>
<p>this的动态切换，b固然为JavaScript创造了巨大的灵活性，但也使编程变得困难和模糊。有时需要将this固定下来，避免出现意想不到的情况。JavaScript提供了 <strong>call</strong>，<strong>apply</strong>，<strong>bind</strong> 来切换/固定this的指向</p>
</blockquote>
<p><strong>Function.prototype.call()</strong><br>函数实例的 <strong>call</strong> 方法可以指定函数内部 <strong>this</strong> 的指向（即函数执行时所在的作用域），然后在指定的作用域中调用该函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">var f = function() &#123;</div><div class="line">   return this;</div><div class="line">&#125;;</div><div class="line">f();</div><div class="line">console.log(f() === window)  //true</div><div class="line">console.log(f.call(obj) === obj)  //true</div></pre></td></tr></table></figure></p>
<blockquote>
<p>关于call方法的参数：call方法中参数应该是一个对象，如果没有参数或参数 为undefined，null则默认传入全局对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var n = 123;</div><div class="line">var obj = &#123;n: 456&#125;;</div><div class="line">function a() &#123;</div><div class="line">   console.log(this.n);</div><div class="line">&#125;</div><div class="line">a.call();   //123</div><div class="line">a.call(undefined);   //123</div><div class="line">a.call(null);   //123</div><div class="line">a.call(window);   //123</div><div class="line">a.call(obj);   //456</div></pre></td></tr></table></figure></p>
<p>call方法还可以接收多个参数：func.call(this.Value， arg1， arg2， arg3， …)；第一个参数是this指向的那个对象，而后面的参数则是函数调用时所需要的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function add(a, b)&#123;</div><div class="line">  return a + b;</div><div class="line">&#125;</div><div class="line">add.call(this, 1, 2);   //3</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>call方法的应用场景：</strong>调用对象的原生方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;</div><div class="line">obj.hasOwnProperty(&apos;toString&apos;)   //false</div><div class="line">//定义一个函数名相同的函数进行覆盖</div><div class="line">obj.hasOwnProperty = function() &#123;</div><div class="line">   return true;</div><div class="line">&#125;</div><div class="line">obj.hasOwnProperty(&apos;toString&apos;)   //true</div><div class="line"></div><div class="line">Object.prototype.hasOwnProperty.call(obj, &apos;toString&apos;)   //false</div><div class="line">//上述代码中，hasOwnProperty是obj继承的方法，如何这个方法被覆盖，就不会调用到正确的结果.而call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放在obj对象中执行，这样无论obj上有没有同名方法，都不会影响到结果</div></pre></td></tr></table></figure></p>
<p><strong>Function.prototype.apply()</strong><br><strong>apply</strong> 方法与 <strong>call</strong> 方法类似，都是改变在函数内部中this的指向，但不同的是apply所接受的第二个参数不同，它并不是一个个函数调用时所需的参数，而是所需参数的集合。</p>
<blockquote>
<p>关于apply方法的参数：func.apply（thisValue， [arg1, arg2, arg3, …），如果参数为undefined，null则默认传入全局对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f(a, b)&#123;</div><div class="line">   return a + b;</div><div class="line">&#125;</div><div class="line">f.call(undefined, 1, 2);   //3</div><div class="line">f.apply(undefined, [1, 2]);   //3</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>利用apply做出一些有趣的应用</strong></p>
<ol>
<li><p>找出数组中最大的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 2, 5, 3, 10, 56, 20];</div><div class="line">Math.max.apply(null, arr);   //56</div></pre></td></tr></table></figure>
</li>
<li><p>将数组中的空元素变为undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a&apos;, &apos; &apos;, &apos;b&apos;];</div><div class="line">Array.apply(null, arr);   //[&apos;a&apos;, undefined, &apos;b&apos;]</div><div class="line"></div><div class="line">//空元素与undefined的区别在于当forEach遍历数组是会跳过数组中的空元素，但不会跳过undefined。</div><div class="line">var arr = [&apos;a&apos;, &apos; &apos;, &apos;b&apos;];</div><div class="line">function print(i) &#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div><div class="line">arr.forEach(print);   //a, b</div><div class="line">Array.Apply(null, arr).forEach(print)   //a, undefined, b</div></pre></td></tr></table></figure>
</li>
<li><p>转换伪数组的对象（例如arguments对象）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;);   //[1]</div><div class="line">Array.prototype.slice.apply(&#123;0: 1&#125;);   //[]</div><div class="line">Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;);   //[1, undefined]</div><div class="line">Array.prototype.slice.apply(&#123;length: 1&#125;);   [undefined]</div><div class="line"></div><div class="line">// apply方法的参数是一个伪数组对象，这个方法起作用的前提是必须要有相对应的键值对和length属性</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>Function.prototype.bind()</strong></p>
<blockquote>
<p>bind()用于将函数体内部的this绑定到一个对象上，然后返回一个新函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var d = new Date();</div><div class="line">d.getTime()   //1481869925657</div><div class="line">var print = d.getTime；</div><div class="line">print();   //Uncaught TypeError: this is not a Date object.</div><div class="line"></div><div class="line">//解决方案</div><div class="line">var print = d.getTime.bind(d);</div><div class="line">print();   //1481869925657</div><div class="line">//上面方法中，bind方法将getTime方法内部的this绑定到d对象，这时候就可以安全赋值给其他对象了。</div></pre></td></tr></table></figure></p>
<p>bind方法的参数就是要绑定this的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var counter = &#123;</div><div class="line">   var count: 0,</div><div class="line">   inc: function() &#123;</div><div class="line">      this.count++;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">var func = counter.inc.bind(counter);</div><div class="line">func();</div><div class="line">console.log(counter.count)   //1</div><div class="line">//上面代码中，counter.inc方法赋值给func。这是必须用bind方法将inc内部的this绑定到counter上否则会出错</div></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//用this绑定到其他对象上的栗子</div><div class="line">var counter = &#123;</div><div class="line">   var count: 0,</div><div class="line">   inc: function() &#123;</div><div class="line">      this.count++;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">var obj = &#123;</div><div class="line">   count: 100;</div><div class="line">&#125;</div><div class="line">var func = counter.inc.bind(obj);</div><div class="line">func();</div><div class="line">console.log(obj.count);   //101</div></pre></td></tr></table></figure>
<p></p><p>在平时代码书写中要注意的两点</p><br><strong>回调函数是JavaScript常见的模式之一，但是常见的错误是，将包含的this方法直接当作回调函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var counter = &#123;</div><div class="line">   count: 0,</div><div class="line">   inc: function() &#123;</div><div class="line">      &apos;use strict&apos;;</div><div class="line">      this.count++;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">function callIt(callback)&#123;</div><div class="line">   callback();</div><div class="line">&#125;;</div><div class="line">callIt(counter.inc.bind(counter));   //把this所在的函数作为回调函数时要注意要把counter.inc方法绑定在counter上这样才不会出错</div><div class="line">counter.count   //1</div></pre></td></tr></table></figure><p></p>
<p><strong>还有一种比较隐蔽的就是某些数组中的方法接收一个匿名函数，内部this的指向很有可能也会出现问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">   name: &apos;张三&apos;,</div><div class="line">   times: [1, 2, 3],</div><div class="line">   print: function() &#123;</div><div class="line">      this.times.forEach(function(n) &#123;</div><div class="line">         console.log(this.name);</div><div class="line">      &#125;);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">obj.print();   //不会有任何输出因为此时的this指向window</div><div class="line">//改造后</div><div class="line">var obj = &#123;</div><div class="line">   name: &apos;张三&apos;,</div><div class="line">   times: [1, 2, 3],</div><div class="line">   print: function() &#123;</div><div class="line">      this.times.forEach(function(n) &#123;</div><div class="line">         console.log(this.name);</div><div class="line">      &#125;.bind(this);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">obj.print();   //张三， 张三， 张三</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>编程题：——《牛客网》</strong><br>封装函数f，使f的this指向指定的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//方法1</div><div class="line"> function bindThis(func, oTarget) &#123;</div><div class="line">    return function() &#123;</div><div class="line">       return func.apply(oTarget, arguments);</div><div class="line">    &#125;</div><div class="line"> &#125;;</div><div class="line">//方法2</div><div class="line"> function bindThis(func, oTarget) &#123;</div><div class="line">    return func.bind(oTarget);</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p>
</blockquote>
</h5></h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h3&gt;关于JS中this知识点的总结&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h5&gt; 在闭包中使用 &lt;strong&gt;this&lt;/strong&gt; 对象以及 &lt;strong&gt;this&lt;/strong&gt; 指向问题&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>webpack工程实践总结</title>
    <link href="http://yoursite.com/webpack%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/webpack工程实践总结/</id>
    <published>2017-10-16T09:07:26.000Z</published>
    <updated>2017-10-16T09:10:11.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack工程实践总结"><a href="#webpack工程实践总结" class="headerlink" title="webpack工程实践总结"></a>webpack工程实践总结</h2><p><strong>本文总结的问题</strong></p>
<ol><br>     <li>什么是 <span style="background:#ccc">webpack</span>，它解决什么问题？</li><br>     <li>对 <span style="background:#ccc">webpack</span> 的主要配置项进行分析，如果我们有什么需求，我们该从哪些配置项着手修改？</li><br>     <li>分析 <span style="background:#ccc">create-react-app</span> 的基础配置文件</li><br>    <li>项目中对 <span style="background:#ccc">webpack</span> 的总结</li><br></ol>

<pre><code>//一个常见的`webpack`配置文件
const webpack = require(&apos;webpack&apos;); 
const HtmlWebPlugin = require(&apos;html-webpack-plugin&apos;);
const ExtractTextPlugin = require(&apos;extrract-text-webpack-plugin&apos;);

module.exports = {
       enter: _dirname + &quot;/app/main.js&quot;, //唯一的入口文件
       output: {
            path: _dirname + &quot;/build&quot;,
            filename: &quot;bundle-[hash].js&quot;
            },
            devtool: &apos;none&apos;,
            devServer: {
               ContentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
               historyApiFallback: true, //不跳转
               inline: true,
               hot: true
               },
        module: {
            rules: [
                    {
                     test: /(\.jsx|\.js)$/,
                     use: {
                           loader: &quot;babel-loader&quot;
                           },
                     exclude: /node_modules/
                     }, {
                     test: /\.css$/,
                     use: ExtractTextPlugin.extract({
                          fallback: &quot;style-loader&quot;,
                          use: [{
                               loader: &quot;css-loader&quot;,
                               options: {
                                  modules: true
                                  }
                               }, {
                               loader: &quot;postcss-loader&quot;
                                  }],
                             })
                          }
                        }
                     ]
                  },
                  plugins: [
                    new webpack.BannerPlugin(&apos;迷途小书童，来打我呀！&apos;)，
                    new HtmlWebpackPlugin({
                        template: _dirname + &quot;/app/index.tmpl.html&quot; //一个插件的实例，并传入相关的参数
                        }),
                    new webpack.optimize.OccurrenceOrderPlugin(),
                    new webpack.optimize.UglifyJsPlugin(),
                    new ExtractTextPlugin(&quot;style.css&quot;)
                    ],
               };
</code></pre><p><strong>解决第一问：</strong><b style="color:#000">什么是WebPack，为什么使用？</b></p>
<p>为什么使用webpack</p><br>&gt;现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出； 很多很好的实践方法<br><br><ul><br><li>模块化，让我们可以把复杂的复杂细化为小的文件</li><br><li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转化为JavaScript文件使浏览器可以识别；</li><br><li>Scss, Less等CSS预处理器</li><br></ul><br>这些改进确实大大提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。<br><p>为什么使用webpack</p><br>&gt;WebPack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss,TypeScript等），并将其转换和打包为适合的格式供浏览器使用。<br><br><p>WebPack和Grunt以及Gulp相比有什么特性</p><br>&gt;其实WebPack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程工具，而WebPack是一种模块化的解决方案，不过WebPack的优点使得WebPack在很多场景下可以代替Gulp/Rrunt类的工具。<br>&gt;<br><br>&gt;Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。<br><br><img src="./1.jpg" alt="Grunt和Gulp的工作流程"><br><p style="color:#ccc; text-align:center; text-decoration: underline">Grunt和Gulp的工作流程</p>

<blockquote>
<p>WebPack的工作方式是：把你的项目当作一个整体，通过一个给定的主文件（如：index.js），WebPack将从这个文件开始找到你的项目所有的依赖文件，使用loader处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>
</blockquote>
<p><img src="./2.png" alt="Webpack工作方式"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">Webpack工作方式</p>

<p><b>如果实在要把两者进行比较，WebPack的处理速度更快更直接，能打包更多不同类型的文件。</b></p>
<p><strong>开始使用WebPack</strong></p>
<p style="color:red">安装</p><br><p> <span style="background:#ccc">WebPack</span> 可以使用 <span style="background:#ccc">npm </span>安装，新建一个空的练习文件夹（此处命名为<span style="background:#ccc"> webpack sample project </span>），在终端中转到该文件夹后执行下述指令就可以完成安装。<br><br>    //全局安装<br>    npm install -g webpack<br>    //安装到你的项目目录<br>    npm install –save-dev webpack<br><br></p><p style="color:red">正式使用WebPack前的准备</p><br>1.在上述练习文件夹中创建一个 <span style="background:#ccc">package.json</span> 文件；这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务。在终端中使用 <span style="background:#ccc"> npm init </span> 命令可以自动创建这个<span style="background:#ccc">package.json</span> 文件<br><br>    npm init<br><br>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，如果不准备在  <span style="background:#ccc"> npm</span> 中发布你的模块，这些问题答案都不重要，回车默认即可。<br><br>2.<span style="background:#ccc"> package.json </span>文件已经就绪，我们在本项目安装 <span style="background:#ccc">WebPack </span> 作为依赖包<br><br>    //安装webpack<br>    npm install –save-dev webpack<br><br>3.回到之前的空文件夹，并在里面创建两个文件夹和<span style="background:#ccc"> public</span> 文件夹，<span style="background:#ccc"> app</span> 文件夹用来存放原始数据和我们将写的 <span style="background:#ccc"> JavaScript</span> 模块，<span style="background:#ccc"> public</span> 文件夹用来存放之后供浏览器读取的文件（包括使用<span style="background:#ccc"> webpack</span> 打包生成的js文件以及一个<span style="background:#ccc"> index.js </span> 文件）。接下来我们再创建三个文件：<br><ol><br>   <li><span style="background:#ccc">index.html</span> ——放在public文件夹中；</li><br>   <li><span style="background:#ccc">Greeter.js</span> ——放在app文件夹中；</li><br>   <li><span style="background:#ccc">main.js</span> ——放在app文件夹中；</li><br></ol><br><br>项目结构图：<br><img src="./3.png" alt="项目结构"><br><p style="color:#ccc; text-align:center; text-decoration: underline">项目结构</p>

<p>我们在<strong>index.html</strong>文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们把打包后的js文件命名为 <span style="background:#ccc">bundle.js</span>）</p>

<pre><code>&lt;!-- index.html --&gt;
&lt;!DOCUTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
   &lt;head&gt;
       &lt;meta charset=&quot;utf-8&quot;&gt;
       &lt;title&gt;WebPack Sample Project&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
       &lt;div id=&apos;root&apos;&gt;&lt;/div&gt;
       &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>我们在 <span style="background:#ccc">Greeter.js</span> 中定义一个返回包含问候信息的 <span style="background:#ccc">html</span> 元素的函数，并依据<span style="background:#ccc">CommonJS</span> 规范导出这个函数为一个模块：</p>

<pre><code>//Greeter.js
module.exports = function(){
   var greet = document.createElement(&apos;div&apos;);
   greet.textContent = &quot;Hi there and greeting!&quot;;
   return greet;
 };
</code></pre><p> <span style="background:#ccc">main.js</span> 文件中我们写入下述代码，用以把 <span style="background:#ccc">Greeter模块</span> 返回的节点插入页面。</p>

<pre><code>//main.js
const greeter = require(&apos;./Greeter.js&apos;);
document.querySelector(&quot;#root&quot;).appendChild(greeter());
</code></pre><p><strong>使用webpack</strong><br>webpack可以在终端中使用，在基本的使用方法如下：</p>
<blockquote>
<h1 id="extry-file-处填写入口文件的路径，本文中就是上述main-js的路径，"><a href="#extry-file-处填写入口文件的路径，本文中就是上述main-js的路径，" class="headerlink" title="{extry  file}处填写入口文件的路径，本文中就是上述main.js的路径，"></a>{extry  file}处填写入口文件的路径，本文中就是上述main.js的路径，</h1><h1 id="destination-for-bundled-file-处填写打包文件的存放路径"><a href="#destination-for-bundled-file-处填写打包文件的存放路径" class="headerlink" title="{destination for bundled file}处填写打包文件的存放路径"></a>{destination for bundled file}处填写打包文件的存放路径</h1><h1 id="填写路径的时候不用添加"><a href="#填写路径的时候不用添加" class="headerlink" title="填写路径的时候不用添加{}"></a>填写路径的时候不用添加{}</h1><p> webpack {enter file} {destination for bundled file}</p>
</blockquote>
<p> 指定入口文件后，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果你的webpack不是全局安装的，那么当你在终端中使用此命令式，需要额外指定其在node_modules中的地址，以上面的例子，在终端中输入如下命令</p>
<pre><code># webpack非全局安装的情况
node_modules/.bin/webpack app/main public/bundle.js
</code></pre><p>结果如下：<br><img src="./4.jpg" alt="使用命令行打包"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">使用命令行打包</p>

<p>可以看出 <span style="background:#ccc">webpack</span> 同时编译了 <span style="background:#ccc">main.js</span> 和 <span style="background:#ccc">Greeter.js</span> ，现在打开 <span style="background:#ccc">index.js</span> ,可以看到如下结果</p><br><img src="./5.png" alt="htmlResult"><br><p style="color:#ccc; text-align:center; text-decoration: underline">htmlResult1</p>

<p>使用 <span style="background:#ccc">webpack</span> 打包一个文件。但在终端进行复杂的操作，其实并不太方便且复杂容易出错，介绍另一种 <span style="background:#ccc">webpack</span> 的常见用法</p>

<p><strong>通过配置文件来使用 <span style="background:#ccc">webpack</span></strong><br><span style="background:#ccc">webpack</span>拥有很多其它的比较高级的功能（比如 <span style="background:#ccc">loaders</span> 和 <span style="background:#ccc">plugins</span>），这些功能其实都可以通过命令行模式实现，但是较容易出错，更好的方法就是配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有打包相关的信息放在里面。</p>
<p><title>如何配置？</title></p>
<p>在当前练习文件夹的根目录下新建一个名为 <span style="background:#ccc">webpack.config.js</span> 的文件</p>，我们在其中写入以下配置代码，此配置涉及的内容是入口文件路径和打包文件的存放路径。<br><br>    modules.exports = {<br>      entry: _dirname + “/app/main.js”, //唯一的入口文件<br>      output: {<br>             path: _dirname + “/public”, //打包后存放的地方<br>             filename: “bundle.js” //打包后输出文件的文件名<br>            }<br>         }<br>&gt;<b>注：</b>“_dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。<br><br>有了这个配置之后，再打包文件，只需在终端里运行 <span style="background:#ccc">webpack（非全局安装需使用node_modules/.bin/webpack）</span> 命令就可以了，这条命令会自动引用<span style="background:#ccc">webpack.config.js</span> 文件中的配置选项<br><img src="./6.jpg" alt="配合配置文件进行打包"><br><p style="color:#ccc; text-align:center; text-decoration: underline">配合配置文件进行打包<br></p>

<p><strong>更快捷的执行打包任务</strong><br>在命令行中输入命令需要代码类似于 <span style="background:#ccc">webpack.config.js</span> 这样的路径是比较烦人的，不过值得庆幸的是 <span style="background:#ccc">npm</span> 可以引导任务执行，对  <span style="background:#ccc">npm</span> 进行配置后可以在命令行中使用简单的 <span style="background:#ccc">npm start</span> 命令来代替上面较为繁琐的命令。在 <span style="background:#ccc">package.json</span> 中对 <span style="background:#ccc">scripts</span> 对象进行相关设置即可，设置方法如下：</p>
<pre><code>{
  &quot;name&quot;: &quot;webpack-sample-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Sample webpack project&quot;,
  &quot;scripts&quot;: {
      &quot;start&quot;: &quot;webpack&quot;  //修改的是这里，JSON文件不支持注释，引用时请清除
      },
  &quot;author&quot;: &quot;Tim&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
      &quot;webpack&quot;: &quot;^1.12.9&quot;
       }
   }
</code></pre><blockquote>
<p><b>注：</b> <span style="color:#666">webpack.json</span> 中的 <span style="color:#666">script</span> 会安装一定顺序寻找命令对应位置，本地的<span style="color:#666">node_modules/.bin</span> 路径就在这个寻找清单中，所以无论是全局还是局部安装的WebPack，你都不需要写前面那指明详细的路径了。</p>
</blockquote>
<p>npm的 <span style="background:#ccc">start</span> 命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用 <span style="background:#ccc">npm start</span> 就可以执行其对应的命令，如果对应的此脚本名称不是 <span style="background:#ccc">start</span>，想要在命令行中运行时，需要这样用 <span style="background:#ccc">npm run { script name }</span> 如 <span style="background:#ccc">npm run build</span>，我们在命令行输入 <span style="background:#ccc">npm start</span> 结果如下：<br><img src="./7.jpg" alt="使用 npm 命令打包代码"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">使用npm start 打包代码</p>

<p>现在只需要使用 <span style="background:#ccc">npm start</span> 就可以打包文件了，但要充分发挥其强大的功能我们需要修改配置文件的其他选项。</p>
<p><strong>Webpack的强大功能</strong><br><b>生成Source Maps（使调试更容易）</b></p><p></p>
<p>开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件不容易找到出错的地方，对应的你写的代码的位置，<span style="background:#ccc">Source Maps</span> 就是来帮我们解决这个问题的。</p><br><p>通过简单的配置， <span style="background:#ccc">webpack</span> 就可以为我们自动生成 <span style="background:#ccc">source maps</span>，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。  </p><br><p>在 <span style="background:#ccc">webpack</span> 的配置文件中配置  <span style="background:#ccc">source maps</span>，需要配置 <span style="background:#ccc">devtool</span>，它有以下四种不同的配置选项，各项优缺点描述如下： </p><br><table><br>     <tr><br>          <th>devtool选项</th><br>        <td><span style="background:#ccc">source map</span></td><br>        <td><span style="background:#ccc">cheap-module-source-map</span></td><br>        <td><span style="background:#ccc">eval-source-map</span></td><br>        <td><span style="background:#ccc">cheap-module-eval-source-map</span></td><br>   </tr><br>     <tr><br>          <th>配置结果</th><br>           <td>在一个单独的文件产生一个完整且功能完全的文件。这个文件具有最好的 <span style="background:#ccc">source map</span>，但是它会减慢打包速度。</td><br>              <td>在一个单独的文件产生一个不带列映射的 <span style="background:#ccc">map</span>，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</td><br>             <td>使用 <span style="background:#ccc">eval</span> 打包源文件模块，在同一个文件中生成完整的<span style="background:#ccc">source map</span>，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项</td><br>              <td>这是在打包文件时最快的生成 <span style="background:#ccc">source map</span> 的方法，生成的<span style="background:#ccc">Source Map</span> 会和打包后的 <span style="background:#ccc">JavaScript</span> 文件同行显示，没有列映射，和<span style="background:#ccc">eval-source-map</span> 选项具有相似的缺点</td><br>   </tr><br></table><br><p>正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的执行有一定影响。</p><br><p>对小到中型的项目中，<span style="background:#ccc">eval-source-map</span> 是一个很好的选项，再次强调你只应该开发阶段使用它，我们继续对上文新建的 <span style="background:#ccc">webpack.config.js</span></p>，进行如下配置：<br><br>    module.exports = {<br>        devtool: ‘eval-source-map’,<br>        entry: _dirname + “/app/index.js”,<br>        output: {<br>          path: _dirname + “/public”,<br>          filename: “bundle.js”<br>          }<br>        }<br><br> &gt;<span style="color:#666">cheap-module-eval-source-map</span> 方法构建速度更快，但不利于调试，推荐在大型项目考虑时间成本时使用。<br><br> <br><strong>使用webpack构建本地服务器</strong><br> &gt;如果想让浏览器监听你的代码的修改，并自动刷新修改后的结果，其实 <span style="background:#ccc">webpack</span> 提供一个可选的本地开发服务器，这个本地服务器基于 <span style="background:#ccc">node.js</span> 构建，可以实现你想要的这些功能，不过他是个单独的组件，在 <span style="background:#ccc">webpack</span> 中进行配置之前需要安装它作为项目依赖<br><br><br>    npm install –save-dev webpack-dev-server<br><br>devServer作为webpack配置选项中的一项，下面是它的一些常见的配置选项<br><table><br>     <tr><br>          <th>devtool配置选项</th><br>        <td><span style="background:#ccc">contentBase</span></td><br>        <td><span style="background:#ccc">port</span></td><br>        <td><span style="background:#ccc">inline</span></td><br>        <td><span style="background:#ccc">historyApiFallback</span></td><br>   </tr><br>     <tr><br>          <th>功能描述</th><br>           <td>默认<span style="background:#ccc">webpack-dev-server</span>，会为根文件夹提供本地服务器，如果想为另外一个目录文件提供本地服务器，应该在这里设置其所在目录（本例设置到”public”目录）</td><br>              <td>设置默认监听端口，如果省略，默认为”8080”</td><br>             <td>设置为 <span style="background:#ccc">true</span> 当源文件改变时会自动刷新页面</td><br>              <td>在开发单页应用时非常有用，它依赖于<span style="background:#ccc">HTML5 history API</span>，如果设置为<span style="background:#ccc">true</span>，所有的跳转都会指向index.html  </td><br>   </tr><br></table><br><br><p>把这些命令加到webpack的配置文件中，现在的配置文件 <span style="background:#ccc">webpack.config.js</span> 如下所示</p>

<pre><code>module.exports = {
   devtool: &apos;eval-source-map&apos;,

   enter: _dirname + &quot;/app/main.js&quot;,
   output: {
     path: _dirname + &quot;/public&quot;,
     filename: &apos;bundle.js&apos;
     },

    devServer: {
      contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
      historyApiFallback: true, //不跳转
      inline： true  //实时刷新
      }  
   }
</code></pre><p>在 <span style="background:#ccc">package.json</span> 中的 <span style="background:#ccc">script</span> 对象中添加如下命令，用以开启本地服务器：</p>

<pre><code>&quot;script&quot;: {
   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
   &quot;start&quot;: &quot;webpack&quot;,
   &quot;server&quot;: &quot;webpack-dev-server --open&quot;
 },
</code></pre><p> 在终端中输入 <span style="background:#ccc">npm run server</span> 即可在本地的 <span style="background:#ccc">8080</span> 端口查看结果</p>


<p><img src="./9.jpg" alt="开启本地服务器"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">开启本地服务器</p>

<p><strong>Loaders</strong></p>
<p><span style="background:#ccc">Loaders</span> 是 <span style="background:#ccc">webpack</span> 提供的最激动地功能。通过不同的<span style="background:#ccc">loader</span>，<span style="background:#ccc">webpack</span> 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换SCSS为CSS，或者把下一代的JS文件（ES6，ES7）转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React中用到的JSX文件转化成JS文件。</p><br>Loaders需要单独安装并且需要在<span style="background:#ccc">webpack。config.js</span> 中的 <span style="background:#ccc">modules</span> 关键字下进行配置，Loaders的配置包括以下几个方面：<br><ul><br>        <li><span style="background:#ccc">test</span>：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><br>        <li><span style="background:#ccc">loader</span> : loader的名称（必须） </li><br>         <li><span style="background:#ccc">include/exclude</span> :  手动添加必须处理的文件（文件夹）或屏蔽不需要的文件（文件夹）（可选）；</li><br>         <li><span style="background:#ccc">query</span> ： 为loaders提供额外的设置选项（可选）</li><br></ul><br><br><p>不过在配置loader之前，我们把 <span style="background:#ccc">Greeter.js</span> 里的问候消息放在一个单独的JSON文件里，并通过合适的配置使<span style="background:#ccc">Greeter.js</span> 可以读取该JSON文件的值，各文件的代码如下：</p><br><p>在app文件夹中创建带有问候信息的JSON文件（命名为<span style="background:#ccc">config.js</span>）</p>

<pre><code>{
  &quot;greetText&quot;: &quot;Hi there and greetings from JSON&quot;
}
</code></pre><p>更新后的Greeter.js</p>

<pre><code>var config = require(&apos;./config.json&apos;);

module.exports = function(){
  var greet = document.createElement(&apos;div&apos;);
  greet.textContent = config.greetText;
  return greet;
};
</code></pre><blockquote>
<p><strong>注：</strong>由于 <span style="color:#666">webpack3. / webpack2.</span>已经内置可处理JSON文件，这里我们无需再添加 <span style="color:#666">webpack1.</span> 需要的 <span style="color:#666">json-loader</span></p>
</blockquote>
<p><strong>Bable</strong></p>
<p>Babel其实是一个编译JavaScript的平台，它的强大之处表现于可以通过编译帮你达到以下目的：</p><br><br><ul><br>  <li>使用下一代的JavaScript代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持；</li><br>  <li>使用基于JavaScript进行了拓展的语言，比如React的JSX；</li><br></ul><br><br><strong>Bable的安装与配置</strong><br><p>Babel其实是几个模块化的包，其核心功能位于 <span style="background:#ccc">babel-core</span> 的npm包中，</p>webpack可以把其不同的包整合在一起使用，对于每个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的 <span style="background:#ccc">babel-preset-es2015</span> 包和解析JSX的 <span style="background:#ccc">babel-preset-react</span> 包）。<br><br><p>一次性安装依赖包</p>

<pre><code>// npm一次性安装多个依赖模块，模块与模块之间用空格隔开
npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react
</code></pre><p>在 <span style="background:#ccc">webpack</span> 中配置Babel的方法：</p>
<pre><code>module.exports = {
    entry: _dirname + &quot;/app/main.js&quot;, //已经多次提及的唯一入口文件
    output: {
       path: _dirname + &quot;public&quot;, //打包后的文件存放的地方
       filename： &quot;bundle.js&quot; //打包后输出文件的文件名
       }，
   devtool: &apos;eval-source-map&apos;,
   devServer: {
      contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
      historyApiFallback: true, //不跳转
      inline: true //实时刷新
     },
   module: {
      rules: [
        {
           test: /(\.jsx|\.js)$/,
           use: {
                loader: &quot;babel-loader&quot;,
                option: {
                   preset: [
                       &quot;es2015&quot;: &quot;react&quot;
                       ]
                     }
                   },
           exclude: /node_modules/
         }
       ]
     }
  };
</code></pre><p>配置webpack以后就已经允许使用ES6以及JSX的语法了。继续使用上面的例子进行测试，不过这次会使用React，先安装React和React-DOM</p>

<pre><code>npm install --save react react-dom
</code></pre><p>接下来我们使用ES6的语法，更新 <span style="background:#ccc">Greeter.js</span> 并返回一个React组件 </p>

<pre><code>//Greeter.js
import React, {Component} from &apos;react&apos;
import config from &apos;./config.json&apos;;

class Greeter extents Component{
   render() {
      return (
         &lt;div&gt;
           {config.greetText}
         &lt;/div&gt;  
       );
     }
  }

export default Greeter
</code></pre><p>修改 <span style="background:#ccc">mian.js</span> 如下，使用ES6模块定义和渲染Greeter模块</p>

<pre><code>//main.js
import React from &apos;react&apos;;
import {render} from &apos;react-dom&apos;;
import Greeter from &apos;./Greeter&apos;;

render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;));
</code></pre><p>重新使用npm start</p> 打包，如果之前打开的本地服务器没有关闭，你应该可以在<span style="background:#ccc">localhost:8080</span> 下看到与之前一样的内容，这说明 <span style="background:#ccc">react</span> 和  <span style="background:#ccc">es6</span> 被正常打包了。<br><img src="./11.jpg" alt="localhost:8080"><br><p style="color:#ccc; text-align:center; text-decoration: underline">localhost:8080</p>

<p><strong>Babel的配置</strong></p>
<p>Babel其实可以完全在 <span style="background:#ccc">webpack.config.js</span> 文件中进行配置，但是考虑到babel具有非常多的配置选项，在单一的 <span style="background:#ccc"> webpack.config.js</span> 文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 <span style="color:#f60">“.babelrc”</span> 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们就会提取 出相关部分，分两个配置文件进行配置（webpack会自动调用 <span style="background:#ccc">.babelrc</span> 里的babel配置选项），如下：<br><br>    module.exports = {<br>       entry: _dirname + “/app/main.js”, //已多次提及的唯一入口文件<br>       output: {<br>          path: _dirname + “/public”, //打包后的文件存放的地方<br>          filename: “bundle.js” //打包后输出的文件的文件名<br>          },<br>       devtool: ‘eval-source-map’,<br>       devSaver: {<br>          contentBase: “./public”, //本地服务器所加载的页面所在的目录<br>          historyApiFallback: true, //不跳转<br>          inline: true //实时刷新<br>        },<br>       module: {<br>          rules: [<br>            {<br>               test: /(.jsx|.js)$/,<br>               use: {<br>                   loader: “babel-loader”<br>                  },<br>               exclude: /node_modules/<br>            }<br>          ]<br>        }<br>      };<br><br><br><br><br>    //.babelrc<br>    {<br>      “presets”: [“react”, “es2015”]<br>    }<br><br><br><b>一切皆模块</b><br> </p><p> Webpack有一个不可不说的优点，它把所有的文件都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。<br><br><b>CSS</b><br></p><p>webpack提供两个工具处理表，<span style="background:#ccc">css-loader</span> 和 <span style="background:#ccc">style-loader</span>，两者处理的任务不同，<span style="background:#ccc">css-loader</span>  使你能够使用类似 <span style="background:#ccc">@import</span> 和<span style="background:#ccc">url(…)</span> 的方法实现 <span style="background:#ccc">require()</span> 的功能，<span style="background:#ccc">style-loader</span> 将所有的计算后的样式加入页面中，两者组合在一起使你能够把样式便嵌入webpack打包后的JS文件中。<br><br>    //安装<br>    npm install –save-dev style-loader css-loader<br><br><br><br><br>    //使用<br>    module。exports = {<br>      …<br>       module: {<br>           rules: [<br>                {<br>                  test: /(.jsx|.js)$/,<br>                  use: {<br>                     loader: “babel-loader”<br>                   },<br>                  exclude: /node_modules/<br>                },<br>                {<br>                  test: /.css$/,<br>                  use: [<br>                    {<br>                       loader: “style-loader”<br>                    },<br>                    {<br>                       loader: “css-loader”<br>                    }<br>                  ]<br>                }<br>               ]<br>             }<br>           };<br><br><br>&gt;注意这里对同一个文件引入多个loader的方法<br><br></p><p>接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式</p><br><br>    /<em> main.css </em>/<br>    html {<br>      box-sizing: border-box;<br>      -ms-text-size-adjust: 100%;<br>      -webkit-text-size-adjust: 100%;<br>    }<br><br>    <em>, </em>:before, *:after {<br>      box-sizing: inherit;<br>    }<br><br>    body {<br>      margin: 0;<br>      font-family: ‘Helvetica Neue’, Helvetica, Arial, sans-serif;<br>    }<br><br>    h1, h2, h3, h4, h5, h6, p, ul {<br>      margin: 0;<br>      padding: 0;<br>    }<br><br>我们这里例子中用到的 <span style="background:#ccc">webpack</span> 只有单一的入口， 其它的模块需要通过 <span style="background:#ccc">import</span>，<span style="background:#ccc">require</span> ，<span style="background:#ccc">url</span> 等与入口文件建立其关联，为了让webpack能找到”main.css”文件，我们把它导入”main.js”中，如下<br><br>    //main.js<br>    import React from ‘react’;<br>    import {render} from ‘react-dom’;<br>    import Greeter from ‘./Greeter’;<br><br>    import ‘./main.css’; //使用require导入css文件<br><br>    render(<greeter>, document.getElementById(‘root’));<br><br>&gt;通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独文件的。<br><br><br>上面的代码说明webpack是怎么把css当作模板看待的，咱们继续看一个更加真实的css模块实践。<br><br><b>CSS module </b><br><br><br><a>在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动化完成。</a><br><p>不过前端的另外一部分，CSS发展就相对于来说慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。<br></p><p style="color : #f60;">CSS module的技术就意在把JS的模块化思想带入到CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules”传递到所需要的地方，然后就可以直接把CSS的类名传递到组件代码中，且这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突。具体代码如下：<br><br>    module.exports = {<br>       …<br><br>       module: {<br>           rules: [<br>             {<br>                test: /(.jsx|.js)$/,<br>                use: {<br>                   loader: “babel-loader”<br>                  },<br>                exclude: /node_modules/<br>             },<br>             {<br>                test: /.css$/,<br>                use: [<br>                     {<br>                        loader: “style-loader”<br>                     },{<br>                        loader: “css-loader”,<br>                        options: {<br>                            modules: true<br>                          }<br>                        }<br>                      ]<br>                    }<br>                  ]<br>                }<br>              };<br>在app文件夹下创建一个 <span style="background:#ccc">Greeter.css</span> 文件<br><br>    .root {<br>       background-color: #eee;<br>       padding: 10px;<br>       barder: 3px solid #ccc;<br>     }<br>导入 <span style="background:#ccc">.root</span> 到Greeter.js中<br><br>    import React, {component} from ‘react’;<br>    import config from ‘./config.json’;<br>    import styles from ‘./Greeter.css’; //导入<br><br>    class Greeter extends Component{<br>      render() {<br>         return(<br>           <div classname="{styles.root}"> //添加类名<br>             {config.greetText}<br>           </div><br>          );<br>        }<br>      }<br><br>     export default Greeter<br></p><p>即使相同类名也不会造成污染<br><br><img src="./15.jpg" alt="应用了css module后的样式"><br></p><p style="color:#ccc; text-align:center; text-decoration: underline">应用了css module后的样式</p>

<p><b>CSS 预处理器</b><br><span style="background:#ccc">Sass</span> 和 <span style="background:#ccc">Less</span> 之类的预处理器是对原生CSS进行拓展，它们允许你使用类似于 <span style="background:#ccc">variables</span>，<span style="background:#ccc">nesting</span>，<span style="background:#ccc">mixins</span>，<span style="background:#ccc">inheritance</span>等不存在于CSS中的特性来写CSS，CSS预处理器可以使得这些特殊类型的语句转化为浏览器可识别的CSS语句。在webpack里使用相关的loaders进行配置就可以使用了，以下是常见的CSS处理 <span style="background:#ccc">loaders</span> :</p>
<p><ul><br>    <li style="color:#ccc">Less Loader</li><br>    <li style="color:#ccc">Sass Loader</li><br>    <li style="color:#ccc">Stylus Loader</li><br></ul><br><a>不过也存在一个CSS的处理平台 <span style="background:#ccc">PostCSS</span> 使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。</a></p>
<p>安装 <span style="background:#ccc">postcss-loader</span> 和 <span style="background:#ccc">autoprefixer(自动添加前缀的插件)</span></p>

<pre><code>npm install --save-dev postcss-loader autoprefixer
</code></pre><p>接下来，在webpack配置文件中添加<span style="background:#ccc">postcss-loader</span>，在根目录新建<span style="background:#ccc">postcss.config.js</span>，并添加如下代码之后，重新使用<span style="background:#ccc">npm start</span> 打包时，你写的css会自动添加不同前缀。</p>
<pre><code>//webpack.config.js
module.exports = {
  ...
  module: {
    rules: [
       {
          test: /(\.jsx|\.js)$/,
          use: {
              loader: &quot;babel-loader&quot;
          },
          exclude: /node_modules/
       },
       {
          test: /(\.css$/),
          use: [
             {
               loader: &quot;style-loader&quot;
             },{
               loader: &quot;css-loader&quot;,
               options: {
                   modules: true
                  }
             },{
               loader: &quot;postcss-loader&quot;
             }
           ]
         }
       ]
     }
   }
</code></pre><p>  <br></p>
<pre><code>//postcss.config.js
module.exports = {
  plugins: [
     require(&apos;autoprefixer&apos;)
   ]
 }
</code></pre><p>上述已经谈论了处理JS的Babel和处理CSS的PostCSS的基本用法，它们其实也是两个独立的平台，配合 <span style="background:#ccc">webpack</span> 可以很好的发挥它们的作用。</p>
<p><b>插件（plugins）</b><br><a>插件(plugins)是用来拓展Webpack功能的，他们在整个构建过程中生效，执行相关任务。</a><br><a>Loaders和plugins常常被弄混，但是它们其实是完全不同的东西，可以这么说：loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less…），一次处理一个，插件并不直接操作单个文件，它直接对着整个构建过程起作用。</a></p>
<p>Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>

<p><b>使用插件的方法</b></p>
<p>要使用某个插件，我们需要通过 <span style="background:#ccc">npm</span> 安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组），我们给打包后代码  <a href="https://webpack.js.org/plugins/banner-plugin/" target="_blank" rel="external">添加版权声明的插件</a>。<br><br>    const webpack = require(‘webpack’);<br>    module.exports = {<br>       …<br>          module: {<br>               rules: [<br>                   {<br>                      test: /(.jsx|.js)$/,<br>                      use: {<br>                        loader: “babel-loader”<br>                        },<br>                      exclude: /node_modules/<br>                   },<br>                   {<br>                      test: /.css$/,<br>                      use: [<br>                         {<br>                           loader: “style-loader”<br>                           options:{<br>                                modules: true<br>                               }<br>                          },<br>                          {<br>                            loader: “postcss-loader”<br>                          }<br>                        ]<br>                      }<br>                    ]<br>                  },<br>                  plugins: [<br>                     new webpack.bannerPlugin(‘版权所有，翻版必究’)<br>                   ],<br>                 };<br><br><br>通过这个插件，打包后的JS文件显示如下<br>   <img src="./16.jpg" alt="版权所有，翻版必究"><br>   </p><p style="color:#ccc; text-align:center; text-decoration: underline">版权所有，翻版必究</p>

<p><strong>常见的插件</strong></p>
<h5>HtmlWebpackPlugin</h5><br><p>这个插件的主要作用是依据一个简单的 <span style="background:#ccc">index.html</span> 模板，生成一个自动引用你打包后的JS文件的新 <span style="background:#ccc">index.html</span>。这在每次生成的JS文件名不同时非常有用（比如添加了 <span style="background:#ccc">hash</span> 值）。</p><br><h5>安装</h5>

<pre><code>npm install --save-dev html-webpack-plugin
</code></pre><p>这个插件自动完成了我们之前手动作的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改：</p><br><ol><br>     <li>移除public文件夹，利用此插件， <span style="background:#ccc">index.html</span> 文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。</li><br>      <li>在app目录下，创建一个 <span style="background:#ccc">index.tmpl.html</span> 文件模板，这个模板包含<span style="background:#ccc">title</span> 等必须元素，在编译过程中，插件会依据此模板生成最终的html页面，会自动添加所以来的css，js，favicon等文件，<span style="background:#ccc">index.tmpl.html</span> 中的模板源代码如下：</li><br></ol><br><br>    &lt;!DOCTYPE html&gt;<br>    <html lang="en"><br>      <head><br>         <meta charset="utf-8"><br>         <title>Webpack Sample Project</title><br>      </head><br>      <body><br>         <div id="root"></div><br>      </body><br>    </html><br><br><p>3. 更新 <span style="background:#ccc">webpack</span> 的配置文件，方法同上，新建一个 <span style="background:#ccc">build</span> 文件夹用来存放最终的输出文件</p>

<pre><code>const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
  entry: _dirname + &quot;./app/main.js&quot;  //唯一入口文件
  output: {
     path: _dirname + &quot;/build&quot;,
     filname: &quot;bundle.js&quot;
   },
   devtool: &apos;evel-source-map&apos;,
   devServer: {
      contentBase: &quot;./public&quot;,  //本地服务器所加载的页面所在的目录
      historyApiFallback: true,  //不跳转
      inline: true  //实时刷新
    },
  module: {
      rules: [
          {
             test: /(\.jsx|\.js)$/,
             use: {
                loader: &quot;babel-loader&quot;
               },
                exclude: /node_modules/
          },
          {
             test: /\.csss$/,
             use: [
                 {
                   loader: &quot;style-loader&quot;
                 },{
                   loader: &quot;css-loader&quot;,
                   options: {
                      modules: true
                     }
                  },{
                   loader: &quot;postcss-loader&quot;
                  }
                ]
              }
            ]
          },
          plugins: [
             new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
             new HtmlWebpackPlugin({
                 template: _dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数
                 })
               ],
           };
</code></pre><p>再次执行 <span style="background:#ccc">npm start</span> 你会发现，build文件夹下面生成了 <span style="background:#ccc">bundle.js</span>  和  <span style="background:#ccc">index.html</span> 。<br><img src="./14.png" alt="build文件夹"><br> </p><p style="color:#ccc; text-align:center; text-decoration: underline">build 文件夹</p><p></p>
<p></p><h5>Hot Module Replacement</h5><p></p>
<p><span style="background:#ccc">Hot Module Replacement</span> (HMR) 也是webpack里很有用的插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。</p><br><p>在webpack中实现HMR也很简单，只需要做两项配置<br><ol><br>  <li>在webpack配置文件中添加HMR插件；</li><br>   <li>在Webpack Dev Server中添加”hot”参数；</li><br></ol><br></p><br><p>不过配置完这些后，JS模块其实还不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。</p><br><p>实现方法如下</p><br> <ul><br>       <li><span style="background:#ccc">Babel</span> 和 <span style="background:#ccc">webpack</span> 是独立的工具</li><br>       <li>两者可以一起工作</li><br>       <li>两者可以通过插件拓展功能</li><br>       <li>HMR是一个webpack插件，它让你能在浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配置</li><br>     <li>Babel有一个叫做 <span style="background:#ccc">react-transform-hrm</span> 的插件，可以在不对React模块进行额外配置的前提下让HMR正常工作；</li><br>      </ul><br><p>如何进行额外的配置</p>

<pre><code>const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
   entry: _dirname + &quot;/app/main.js&quot;, //唯一入口文件
   output: {
      path: _dirname + &quot;/build&quot;,
      filename: &quot;bundle.js&quot;
    },
    devtool: &apos;eval-source-map&apos;,
    devServer: {
      contentBase: &quot;./public&quot;, //本地服务器所加载页面所在的目录
      historyApiFallback: true, //不跳转
      inline: true,
      hot: true
    },
    module: {
      rules: [
         {
             test: /(\.jsx|\.js)$/,
             use: {
                 loader: &quot;babel-loader&quot;
                },
             exclude: /node_modules/
         },
         {
             test:/\.css$/,
             use: [
              {
                 loader: &quot;style-loader&quot;
              },
              {
                 loader: &quot;css-loader&quot;,
                 options:{
                     modules: true
                    }
              },
              {
                 loader: &quot;postcss-loader&quot;
              }
            ]
          }
        ]
      },
      plugins: [
         new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
         new HtmlWebpackPlugin({
              template: _dirname + &quot;/app/index.tmpl.html&quot; //插件实例，并传入相关参数
              }),
         new webpack.HotModuleReplacementPlugin()  //热加载插件
       ],
    };
</code></pre><p>安装 <span style="background:#ccc">react-transform-hmr</span></p>

<pre><code>npm install --save-dev babel-plugin-react-transform react-transform-hmr
</code></pre><p></p><p>配置Babel</p>
<pre><code>// .babelrc
{
  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;],
  &quot;env&quot;: {
     &quot;development&quot;: {
        &quot;plugins&quot;: [[&quot;react-transform&quot;,{
               &quot;transforms&quot;: [{
                    &quot;transform&quot;: &quot;react-transform-hmr&quot;,
                    &quot;imports&quot;: [&quot;react&quot;],
                    &quot;locals&quot;: [&quot;module&quot;]
                  }]
                }]]
              }
            }
          }
</code></pre><p> 现在当你使用React时，可以热加载模块了，每次保存就能在浏览器上看到更新内容。<br> </p><h5>产品阶段的构建</h5><p></p>
<p></p><p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如优化，压缩，缓存，以及分离CSS和JS。</p>
<p></p><p>对于复杂的项目来说，需要复杂的配置，这时分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个 <span style="background:#ccc">webpack.production.config.js</span> 的文件，在里面加上基本的配置，它和原始的webpack.config.js很像，如下：</p>
<pre><code>//webpack.production.config.js
const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
    entry: _dirname + &quot;/app/main.js&quot; //唯一的入口文件
    output: {
       path: _dirname + &quot;/build&quot;,
       filename: &quot;bundle.js&quot;
     },
    devtool: &apos;eval-source-map&apos;,
    devServer: {
        contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
        historyApiFallback: true, //不跳转
        inline: true, 
        hot: true
      },
      module: {
         rules: [{
            test: /()\.jsx|\.js}$/,
            use: {
               loader: &quot;babel-loader&quot;
              },
            exclude: /node_modules/
         ],{
            test: /\.css$/,
            use: ExtractTextPlugin.extract({
                  fallback: &quot;style-loader&quot;,
                  use: [{
                       loader: &quot;css-loader&quot;,
                       options: {
                           modles: true
                        }
                     },{
                       loader: &quot;postcss-loader&quot;
                     }],
                  })
                }]
             },
             plugins: [
               new webpack.BannerPlugin(&quot;版权所有，翻版必究&quot;),
               new HtmlWebpackPlugin({
                   template: _dirname + &quot;/app/index.tmpl.html&quot; //new一个插件的实例，并传入相关的参数
                   }),
               new webpack.HotModuleRepalacementPlugin()  //热加载插件     
               ],
           };
</code></pre><p><br></p>
<pre><code>//package.json
{
  &quot;name&quot;: &quot;test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;script&quot;: {
      &quot;test&quot;: &quot;echo \&quot;Error: no test specifie\&quot; &amp;&amp; exit 1&quot;,
      &quot;start&quot;: &quot;webpack&quot;,
      &quot;server&quot;: &quot;webpack-dev-server --open&quot;,
      &quot;build&quot;: &quot;NODE_ENV=production webpack --config ./webpack.production.config.js --progress&quot;
      },
      &quot;author&quot;: &quot;&quot;,
      &quot;license&quot;: &quot;ISC&quot;,
      &quot;devDependencies&quot;: {
      ...
      },
      &quot;dependencies&quot;: {
         &quot;react&quot;: &quot;^15.6.1&quot;,
         &quot;react-dom&quot;: &quot;^15.6.1&quot;
        }
      }
</code></pre></greeter>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;webpack工程实践总结&quot;&gt;&lt;a href=&quot;#webpack工程实践总结&quot; class=&quot;headerlink&quot; title=&quot;webpack工程实践总结&quot;&gt;&lt;/a&gt;webpack工程实践总结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文总结的问题&lt;/strong&gt;&lt;/
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>在vue事件处理中注意的问题</title>
    <link href="http://yoursite.com/%E5%9C%A8vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/在vue事件处理中注意的问题/</id>
    <published>2017-03-22T11:50:44.000Z</published>
    <updated>2017-03-22T12:29:33.982Z</updated>
    
    <content type="html"><![CDATA[<p>###在vue事件处理中注意的问题<br>1.在事件处理程序中调用<strong>event.preventDefault()</strong>或<strong>event.stopPropagation()</strong>是非常常见的需求。尽管我们可以在methods中轻松实现这点，但更好的方法是：methods只是纯粹的数据逻辑，而不是去处理DOM事件细节。为了解决这一问题，vue.js为<strong>v-on</strong>提供了事件修饰符。通过由点（.）表示的指令后缀来调用修饰符.</p>
<ul style="color:#F60"><br> <li>.stop</li><br> <li>.prevent</li><br> <li>.capture</li><br> <li>.self</li><br> <li>.once</li><br></ul>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;   // 阻止单击事件冒泡 </div><div class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;  //提交事件不再重载页面 </div><div class="line">&lt;a v-on:click.stop.prevent=&quot;toThat&quot;&gt;&lt;/a&gt; //字符串可以串联 </div><div class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt; //只有修饰符 </div><div class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; //添加事件侦听器时使用事件捕获模式 </div><div class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; //只有事件在该元素本身（而不是子元素）触发时触发回调 </div><div class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; //-点击事件只会触发一次</div></pre></td></tr></table></figure>
<p><hr><br><strong>按键修饰符</strong><br><code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code><br> <ul style="color:#f60"><br>   <li> .enter</li><br>   <li>`.tab</li><br>  <li>.delete</li><br>  <li>.esc</li><br>  <li>.space</li><br>  <li>.up</li><br>  <li>.dowm</li><br>  <li>.left</li><br>  <li>.right</li><br>  <li>.ctrl</li><br>  <li>.alt</li><br>  <li>.shift</li><br>  <li>.meta</li><br></ul></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###在vue事件处理中注意的问题&lt;br&gt;1.在事件处理程序中调用&lt;strong&gt;event.preventDefault()&lt;/strong&gt;或&lt;strong&gt;event.stopPropagation()&lt;/strong&gt;是非常常见的需求。尽管我们可以在methods中
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="事件处理" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>关于闭包</title>
    <link href="http://yoursite.com/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/关于闭包/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-10-16T09:10:40.528Z</updated>
    
    <content type="html"><![CDATA[<html><head><title>关于闭包</title><meta charset="utf-8"><link href="https://dn-maxiang.qbox.me/res-min/themes/marxico.css" rel="stylesheet"><style></style></head><body><div id="preview-contents" class="note-content"><br><br><br><br><br><br><h3 id="关于闭包">关于闭包</h3><br><br><p><strong>1.为什么要用闭包？</strong> <br><br>在ES5之前具有作用域的仅有函数function。并且有一个特点就是：函数内部可以直接访问外部变量，但在函数外部无法访问函数内部变量，这就是JS语言特有的“链式作用域”结构（chain scope），如果我们要访问函数的内部变量我们就得使用闭包，简单地说，我们使用闭包的主要作用就是间接访问函数的内部数据。 <br><br></p><hr><strong>&lt;1&gt;如何创建闭包</strong><p></p><br><br><br><br><pre class="prettyprint hljs-dark"><code class="hljs delphi">      <span class="hljs-keyword">var</span> num = <span class="hljs-number">12</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showNum</span><span class="hljs-params">()</span><span class="hljs-comment">{<br>        console.log(num);<br>        }</span><br>        <span class="hljs-title">showNum</span><span class="hljs-params">()</span>;</span>   <span class="hljs-comment">//12</span><br></code></pre><br><br><p>在上面代码中执行函数showNum(),因为函数内部可以访问外部变量num，所以执行结果为12.</p><br><br><br><br><pre class="prettyprint hljs-dark"><code class="hljs javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showNum</span>(<span class="hljs-params"></span>)</span>{<br>      <span class="hljs-keyword">var</span> num = <span class="hljs-number">12</span>; <span class="hljs-comment">//此处要注意var声明，否则等于直接声明全局变量num</span><br>      <span class="hljs-built_in">console</span>.log(num);<span class="hljs-comment">//Uncaught ReferentceError: num is not defined</span><br>      }<br></code></pre><br><br><p>由于函数外部不能够访问函数内部变量所以直接访问输出num时，由于此时num并未定义，故抛出异常信息。</p><hr> <br><br><strong>在函数内部定义一个内部函数，并将这个函数当作返回值，这样我们就可以获得函数的局部变量。</strong><p></p><br><br><br><br><pre class="prettyprint hljs-dark"><code class="hljs javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showNum</span>(<span class="hljs-params"></span>)</span>{<br>   <span class="hljs-keyword">var</span> num = <span class="hljs-number">12</span>;<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showNum2</span>(<span class="hljs-params"></span>)</span>{<br>      <span class="hljs-built_in">console</span>.log(num);<br> };<br>   <span class="hljs-keyword">return</span> showNum();<br> }<br> <span class="hljs-keyword">var</span> myNum = showNum();<br>   muNum();  <span class="hljs-comment">//12</span><br></code></pre><br><br><p>在上面的代码中，在函数showNum中嵌一层函数showNum2，由于内层函数可以访问外层函数的变量，所以，执行showNum()函数的，showNum2函数可以直接读取外层函数showNum()的局部变量num的值，并输出12。<br><br><strong>以上实现了闭包的主要作用域之一：读取函数内部变量</strong></p><hr> <br><br><strong>2.还可以将创建变量的值始终保持在内存中，以供本地环境使用</strong><p></p><br><br><br><br><pre class="prettyprint hljs-dark"><code class="hljs javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showNum</span>(<span class="hljs-params"></span>)</span>{<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">12</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showNum2</span>(<span class="hljs-params"></span>)</span>{<br>       <span class="hljs-built_in">console</span>.log(++num);<br>      };<br>       <span class="hljs-keyword">return</span> showNum2;<br>    }<br>    <span class="hljs-keyword">var</span> myNum = showNum();<br>    myNum();   <span class="hljs-comment">//13</span><br></code></pre><br><br><p>一般情况下在函数被调用完后不再被引用时，该函数都会被垃圾回收机制（garbage collection），但是由于上述代码中函数showNum2被myNum引用，而函数showNum2又依赖函数showNum，因此函数showNum不会被垃圾回收</p></div></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;title&gt;关于闭包&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;link href=&quot;https://dn-maxiang.qbox.me/res-min/themes/marxico.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;st
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>阅读笔记(一)</title>
    <link href="http://yoursite.com/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>http://yoursite.com/阅读笔记-一/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-03-22T11:56:11.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读笔记-一"><a href="#阅读笔记-一" class="headerlink" title="阅读笔记(一)"></a>阅读笔记(一)</h1><hr>
<p> <strong>计算属性</strong></p>
<hr>
<p>计算属性应用于一切复杂逻辑<br><br><br>基础实例：<br></p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
    &lt;p&gt;Original message{{message}}&lt;/p&gt;
    &lt;p&gt;computed message{{reversedMessage}}&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>   <br>  </p>
<pre><code>var vm = new Vue({
  el:&quot;#example&quot;,
  data:{message:&apos;Hello&apos;},
  computed:{
  reversedMessage:function(){
           return this message.split(&apos;&apos;).reverse().join(&apos;&apos;)}
           }
});
</code></pre><hr>
<p><strong>说明：</strong></p>
<hr>
<p>这里我们声明了一个计算属性reversedMessage。我们提供的函数将用作属性vm.reversedMessage的getter,这里的reversedMessage得知取决于vm.message<br><br> </p>
<hr>
<p>不难看出我们也可以通过methods来实现：</p>
<pre><code>var vm = new Vue({
  el:&quot;#example&quot;,
  data:{message:&apos;Hello&apos;},
  methods:{
     reversedMessage:function(){
          return this message.split(&apos;&apos;).reversed().join(&apos;&apos;)
            }}; 
</code></pre><hr>
<p>关于computed与methods的区别：<br><br>计算属性存在依赖缓存，计算属性在相关依赖发生变化时才会重新取值，这就意味着只要message不发生改变， 计算属性就会立即返回之前的结果，而不必再执行函数。<br><br><hr>这也就意味着如下计算属性不会更新，因为Date.now()不是响应式依赖。</p>
<pre><code>comptued:{
   now:function(){
     return Data.now()
}}
</code></pre><hr>
<p>相比于计算属性，每次渲染，methods都会执行函数。<br><br><br>关于computed与methods的选择：我们为什么用计算缓存？假设我们有一个重要的计算属性A，这个计算属性需要大量的数组遍历和做巨大的运算，然后我们可能用其他的计算属性依赖A，如果没有缓存我们必须大量执行A的getter！如果不需要缓存请用methods.<br><br><br><hr><br><strong>计算属性&nbsp;VS&nbsp;Watch&nbsp;property</strong></p>
<p>vue.js提供了一个$watch方法，它便于观察Vue实例上的数据变动</p>
<pre><code>&lt;div id=&quot;demo&quot;&gt;{{fullName}}&lt;/div&gt;
</code></pre><p>   <br></p>
<pre><code>var vm = new Vue({
     el:&quot;demo&quot;
     data:{
        firstName:&apos;Foo&apos;,
        lastName:&apos;Bar&apos;,
        fullName:&apos;Foo Bar&apos;}
     watch:{
       firstName:function(){
            this.fullName = val + &apos;&apos; +this.lastName },
       lastName:function(){
            this.fullName = this.first + &apos;&apos; +val },  
     }})
</code></pre><p>   <br></p>
<pre><code>var vm = new Vue({
        el:&quot;demo&quot;
        data:{
            firstName:&apos;Foo&apos;,
            lastName:&apos;Bar&apos;
            },
        computed:{
           fullName:function(){
           return this.firstName + &apos; &apos; + this.lastName}}
        });     
</code></pre><hr>
<p>计算setter:计算属性默认只有getter,在必要时也可以设置setter</p>
<pre><code>computed:{
   fullName:{
      get:function(){
      return this.firstName + &apos; &apos; + this.lastName}
      set:function(newValue){
      var names = newValue.split() 
      firstName = names[0]
      lastName = name[names.length-1]
      }}}
</code></pre><p><br><br>现在更新vm.fullName时，vm.firstName以及vm.lastName也会对应更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读笔记-一&quot;&gt;&lt;a href=&quot;#阅读笔记-一&quot; class=&quot;headerlink&quot; title=&quot;阅读笔记(一)&quot;&gt;&lt;/a&gt;阅读笔记(一)&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt; &lt;strong&gt;计算属性&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;计算属性应用于一切复杂逻
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="计算属性" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>关于瀑布流应该注意的一些问题</title>
    <link href="http://yoursite.com/%E5%85%B3%E4%BA%8E%E7%80%91%E5%B8%83%E6%B5%81%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/关于瀑布流应该注意的一些问题/</id>
    <published>2017-03-01T08:06:31.000Z</published>
    <updated>2017-03-01T08:08:36.783Z</updated>
    
    <content type="html"><![CDATA[<pre><code>**关于瀑布流应该注意的一些问题**
</code></pre><hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;瀑布流的特点： 可以渲染出从后台导出的数据，从而节约前端的内存压力，加快数据加载的速度。<br>&nbsp;&nbsp;&nbsp;&nbsp;其原理：当你滑动滚动条到一定的距离时，窗口会自动加载从后台出来的数据</p>
<hr>
<p>在js文件夹里将data以json数据格式进行处理；</p>
<pre><code>var dataInt={
     &quot;data&quot;:[ {&apos;src&apos;:&quot;0.jpg&quot;}, {&apos;src&apos;:&quot;1.jpg&quot;},
              {&apos;src&apos;:&quot;2.jpg&quot;}, {&apos;src&apos;:&quot;3.jpg&quot;},
              {&apos;src&apos;:&quot;4.jpg&quot;}, {&apos;src&apos;:&quot;5.jpg}]
            }
</code></pre><hr>
<p>将数据塞进HTML结构中；</p>
<pre><code>for(var i=0;i&lt;dataInt.data.length;i++){
 var oBox=document.createElement(&apos;div&apos;);
 oBox.className=&apos;box&apos;;
 oParent.appendChild(oBox);
 var oPic=document.createElement(&apos;div&apos;);
 oPic.className=&apos;pic&apos;;
 oBox.appendChild(oPic);
 var oImg=document.createElement(&apos;img&apos;);
 oImg.src=&quot;images/&quot;+dataInt.data[i].src;
 oPic.appendChild(oImg);}
</code></pre><hr>
<p>除了渲染部分还以该注意在取窗口的高度以及滑块距离窗口顶部时存在浏览器的兼容问题，即，存在混杂模式与非混杂模式，其处理方式为：</p>
<pre><code>var scollTop=document.body.scollTop||document.documentElement.scollTop;
var height=document.body.clientHeight||document.documentElement.clientHeight;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;**关于瀑布流应该注意的一些问题**
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;瀑布流的特点： 可以渲染出从后台导出的数据，从而节约前端的内存压力，加快数据加载的速度。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="waterfall" scheme="http://yoursite.com/tags/waterfall/"/>
    
  </entry>
  
  <entry>
    <title>关于对篮球这项运动的理解</title>
    <link href="http://yoursite.com/%E5%85%B3%E4%BA%8E%E5%AF%B9%E7%AF%AE%E7%90%83%E8%BF%99%E9%A1%B9%E8%BF%90%E5%8A%A8%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/关于对篮球这项运动的理解/</id>
    <published>2017-02-24T08:33:55.000Z</published>
    <updated>2017-02-24T09:35:18.707Z</updated>
    
    <content type="html"><![CDATA[<p><strong>下列言论源于码农的臆想综合征</strong></p>
<hr>
<p>写完不知是几个小时的代码略感疲倦，便写篇对篮球理解的谬论解解乏。<br>全明星还没结束，考辛斯便被国王扫地出门，全明星只打了2分27秒便可知考辛斯的愤懑程度，从来没有人在离全明星这么近的时候交易的，这个交易一下子把全明星赛后的头条给抢了，什么“浓眉哥”的52分，“字母哥”30分，杜兰特的“三双”，三旬老汉的各种暴扣，阿杜给威少的传球，库里抱脑袋卖萌，那些都弱爆了好伐。。。<br>全明星过后安东尼·戴维斯便成了最大的赢家，不知该哭还是该笑，同为肯塔基的同门，不知考辛斯对浓眉耍小脾气他该如何面对…</p>
<p>回归正题，谈谈对篮球的理解，从一个观众角度来说：对于姚老板在36岁的年纪当选篮协主席搁在过去。不敢想象，说明现在的中国男篮的改革真的要动真格的了，但改成什么样，恐怕还没人知道，所以这才是上头选中姚明的原因吧，有了从满想象力的开始，才会有充满想象力的未来，虽然知道姚明会当选，但就在他真的当选时，还是有点感慨万千。</p>
<p>中国篮球这些年毁誉交加，神鬼难辨，说不断，理还乱。单靠政府性政策，一节换一届，已经难以跟上世界篮球的发展潮流和速度，所以，姚明此行，任重道远。姚明打球打到名人堂，演讲演到奥运会和世界杯申办讲台，游历丰富，见多识广，人脉广泛，更有一种对中国篮球的一腔热血，满肚子的改革思想…就此，姚明的权限就不止于CBA，更要担起整个篮球的改革重担，专业人做专业事，便有了上天入地的空间。</p>
<p>回到NBA的赛场…</p>
<p>在湖人的训练馆二层开着这么一扇大窗，很少拉上帘子，靠窗摆着一溜奥克莱恩杯。从窗子往下看去，可以看到整个训练馆的全部四片球场。在球场训练时，队员们一抬头就可以看到金杯，有时会有老板的眼神——以后，在这里注视他们的将是“魔术师”和珍妮。</p>
<p>珍妮-巴斯说干就干，截至交易日的前两天，突然把“魔术师”约翰逊扶正，炒了老臣库普切克的鱿鱼…是的，湖人历史上的“魔术师时代”拉开帷幕。</p>
<p>第一把火就把路易斯·威廉姆斯烧到了火箭换了“骑兵连连长”和一个二轮选秀权，路易斯·威廉姆斯在湖人扮演第一得分手角色，交易他就意味着湖人完全放弃这个赛季，将阵容继续年轻化。</p>
<p>这次“魔术师”出任湖人董事长，与姚明出任篮协主席并列来看。这两个事件某种意义上是同样一个道理：约翰逊和姚都是众望所归，但因为他们不再自己上场打球，因此未来——等着看好戏…</p>
<p>——部分选自苏群老师的理解，未来我们共同见证！  ^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;下列言论源于码农的臆想综合征&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;写完不知是几个小时的代码略感疲倦，便写篇对篮球理解的谬论解解乏。&lt;br&gt;全明星还没结束，考辛斯便被国王扫地出门，全明星只打了2分27秒便可知考辛斯的愤懑程度，从来没有人在离全明星这么近的
    
    </summary>
    
      <category term="Sports" scheme="http://yoursite.com/categories/Sports/"/>
    
    
      <category term="basketball" scheme="http://yoursite.com/tags/basketball/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/正则表达式/</id>
    <published>2017-02-18T16:00:00.000Z</published>
    <updated>2017-02-19T11:55:02.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Javascript中关于正则表达式的一些问题"><a href="#Javascript中关于正则表达式的一些问题" class="headerlink" title="Javascript中关于正则表达式的一些问题"></a>Javascript中关于正则表达式的一些问题</h3><hr>
<p><strong>1.修饰符 </strong><br>  修饰符分为三类：<br>  1）global：全局搜索，不添加，搜索到第一个匹配停止 （g）<br>  2) ignore case：忽略大小写，默认大小写敏感 （i）<br>  3）multiple lines：多行搜索 （m）</p>
<p><strong>2.预定义类</strong><br>  <img src="./D:\Blog_images\正则表达式1.png" alt="Alt text"></p>
<p> 关于预定义类的demo<br>  <img src="./D:\Blog_images\正则表达式2.png" alt="Alt text"></p>
<p><strong>3.量词</strong><br>由于元字符与特殊字符或字符类或者它们的组合（中括号）甚至它们的马甲（预定义类）都是一对一进行匹配。我们要匹配”司徒正美这个词”，最简单都要/…/，如果长达50个字就比较麻烦。因此我们迫切需要一个简单的操作来处理这类的数量关系（量词仅匹配于紧挨着它的字符）。<img src="./D:\Blog_images\正则表达式5.png" alt="Alt text"></p>
<p>比如：<img src="./D:\Blog_images\正则表达式3.png" alt="Alt text"><br><img src="./D:\Blog_images\正则表达式4.png" alt="Alt text"></p>
<p><strong>4.非贪婪模式</strong><br>让正则表达式尽可能少的匹配，也就是说一旦成功匹配不在继续尝试就是非贪婪模式<br>做法很简单，在量词后加上？即可</p>
<blockquote>
<p>‘123456789’.match(/\d(3,5)?/g)<br>[“123”，”456”，”789”] </p>
</blockquote>
<p><strong>5.分组</strong><br>到目前为止，我们只能一个字符到匹配，虽然量词的出现，能帮助我们处理一排密紧密相连的同类型字符。但这是不够的，下面该轮到小括号出场了，中括号表示范围内选择，大括号表示重复次数。小括号允许我们重复多个字符。<img src="D:\Blog_images\正则表达式6.png" alt="Alt text"></p>
<p>以及不同的表达式所体现的不同图形含义<br><img src="./D:\Blog_images\正则表达式7.png" alt="Alt text"><br><img src="./D:\Blog_images\正则表达式8.png" alt="Alt text"></p>
<p>在Console中对分组测试<br><img src="./D:\Blog_images\正则表达式9.png" alt="Alt text"><br><img src="./D:\Blog_images\正则表达式10.png" alt="Alt text"><br><img src="./D:\Blog_images\正则表达式11.png" alt="Alt text"><br><img src="./D:\Blog_images\正则表达式12.png" alt="Alt text"><br><img src="./D:\Blog_images\正则表达式13.png" alt="Alt text"></p>
<p><strong>6.反向引用</strong><br>反向引用标识由正则表达式中的匹配组捕获的子字符串。每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用。<img src="./D:\Blog_images\正则表达式14.png" alt="Alt text"></p>
<p><strong>7.前瞻</strong><br>正则表达式从文本头部向尾部开始解析，文本尾部方向称为”前”<br>前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾、后瞻方向相反。<img src="./D:\Blog_images\正则表达式15.png" alt="Alt text"></p>
<p><img src="D:\Blog_images\正则表达式16.png" alt="Alt text"><br>继续在分组内做文章，前瞻与后瞻其实都属于零宽断言，但js不支持后瞻，正向前瞻用来检查接下来出现的是不是某个特定的字符集。而负向前瞻则是检查接下来不应该出现的特定字符串集。零宽断言是不会捕获的。<img src="./D:\Blog_images\正则表达式17.png" alt="Alt text"><img src="./D:\Blog_images\正则表达式18.png" alt="Alt text"></p>
<p><strong>8.对象属性</strong><br>1）global：是否全文搜索，默认false<br>2）ignore case：是否大小写敏感，默认是false<br>3）multiline：多行搜索，默认值是false<br>4）lastIndex：是当前表达式匹配内容的最后一个字符的下一个位置<br>5）source：正则表达式的文本字符串</p>
<p> 对lastIndex概念的demo<br> <img src="./D:\Blog_images\正则表达式19.png" alt="Alt text"></p>
<p><strong>边界</strong><br>要与字符类合用<br><img src="./D:\Blog_images\正则表达式20.png" alt="Alt text"><br>实现首字母大写<br><img src="./D:\Blog_images\正则表达式21.png" alt="Alt text"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Javascript中关于正则表达式的一些问题&quot;&gt;&lt;a href=&quot;#Javascript中关于正则表达式的一些问题&quot; class=&quot;headerlink&quot; title=&quot;Javascript中关于正则表达式的一些问题&quot;&gt;&lt;/a&gt;Javascript中关于正则表达
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于git命令行上传本地代码项目到github</title>
    <link href="http://yoursite.com/%E5%9F%BA%E4%BA%8Egit%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E9%A1%B9%E7%9B%AE%E5%88%B0github/"/>
    <id>http://yoursite.com/基于git命令行上传本地代码项目到github/</id>
    <published>2017-02-15T16:00:00.000Z</published>
    <updated>2017-02-19T05:25:39.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于本地代码项目运用git命令行的方式上传到代码托管网站的具体步骤"><a href="#关于本地代码项目运用git命令行的方式上传到代码托管网站的具体步骤" class="headerlink" title="关于本地代码项目运用git命令行的方式上传到代码托管网站的具体步骤"></a>关于本地代码项目运用git命令行的方式上传到代码托管网站的具体步骤</h2><blockquote>
<p><1>添加本地与github的ssh key </1></p>
</blockquote>
<hr>
<blockquote>
<p><2>打开本地的git shell   通过cd命令进入你要上传的工程中 执行 git init  再执行git add . （小数点代表的是上传所用的文件）再执行git commit -m “first commit” 再执行 git remote add origin + repository下的URL 再执行git pull 再执行git pull origin master 最后再执行git push -u origin master</2></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于本地代码项目运用git命令行的方式上传到代码托管网站的具体步骤&quot;&gt;&lt;a href=&quot;#关于本地代码项目运用git命令行的方式上传到代码托管网站的具体步骤&quot; class=&quot;headerlink&quot; title=&quot;关于本地代码项目运用git命令行的方式上传到代码托管
    
    </summary>
    
      <category term="Github" scheme="http://yoursite.com/categories/Github/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于Hexo博客的更新问题</title>
    <link href="http://yoursite.com/hello-world/"/>
    <id>http://yoursite.com/hello-world/</id>
    <published>2017-02-08T16:00:00.000Z</published>
    <updated>2017-02-09T13:29:25.876Z</updated>
    
    <content type="html"><![CDATA[<p><strong>部署主题，本地查看效果</strong></p>
<hr>
<p> 返回Hexo目录，右键git bash，输入</p>
<blockquote>
<p>hexo g<br>hexo s</p>
</blockquote>
<hr>
<p>打开浏览器，输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>  即预览本地主题更换</p>
<p><br><br><br><strong>如果效果满意,将它部署到github上</strong></p>
<hr>
<p>打开Hexo文件夹，右键git bash，输入</p>
<blockquote>
<p>hexo clean （必须要，不然有时因为缓存问题，服务器更新不了主题）<br>hexo g -d</p>
</blockquote>
<p><br><br><strong>打开自己主页即可以浏览自己Blog效果</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;部署主题，本地查看效果&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; 返回Hexo目录，右键git bash，输入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hexo g&lt;br&gt;hexo s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;打开浏览器，输入&lt;
    
    </summary>
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
