






<!doctype html>
<html lang="zh-Hans">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Tim-ao">
  
  
  
  
    <meta name="description" content="webpack工程实践总结本文总结的问题
     什么是 webpack，它解决什么问题？     对 webpack 的主要配置项进行分析，如果我们有什么需求，我们该从哪些配置项着手修改？     分析 create-react-app 的基础配置文件    项目中对 webpack 的总结

//一个常见的`webpack`配置文件
const webpack = require(&a...">
  
  <title>webpack工程实践总结 [ Tim-ao ]</title>
  
    <link rel="alternate" href="/atom.xml" title="Tim-ao">
  
  
    <link rel="shortcut icon" href="/1.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
  
    <div class="item next">
      <a href="/在vue事件处理中注意的问题/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        在vue事件处理中注意的问题
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/images/avatar.jpg"/>
          <div id="homelink">Tim-ao</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">主页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">存档</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">关于</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/apacheao/">Github</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>webpack工程实践总结</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2017-10-16</span>
      
        <span id = "post-title-updated">修改于 2017-10-16</span>
      
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/webpack/">webpack</a>
      
      </span>
      
    </p>
    
    <h2 id="webpack工程实践总结"><a href="#webpack工程实践总结" class="headerlink" title="webpack工程实践总结"></a>webpack工程实践总结</h2><p><strong>本文总结的问题</strong></p>
<ol><br>     <li>什么是 <span style="background:#ccc">webpack</span>，它解决什么问题？</li><br>     <li>对 <span style="background:#ccc">webpack</span> 的主要配置项进行分析，如果我们有什么需求，我们该从哪些配置项着手修改？</li><br>     <li>分析 <span style="background:#ccc">create-react-app</span> 的基础配置文件</li><br>    <li>项目中对 <span style="background:#ccc">webpack</span> 的总结</li><br></ol>

<pre><code>//一个常见的`webpack`配置文件
const webpack = require(&apos;webpack&apos;); 
const HtmlWebPlugin = require(&apos;html-webpack-plugin&apos;);
const ExtractTextPlugin = require(&apos;extrract-text-webpack-plugin&apos;);

module.exports = {
       enter: _dirname + &quot;/app/main.js&quot;, //唯一的入口文件
       output: {
            path: _dirname + &quot;/build&quot;,
            filename: &quot;bundle-[hash].js&quot;
            },
            devtool: &apos;none&apos;,
            devServer: {
               ContentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
               historyApiFallback: true, //不跳转
               inline: true,
               hot: true
               },
        module: {
            rules: [
                    {
                     test: /(\.jsx|\.js)$/,
                     use: {
                           loader: &quot;babel-loader&quot;
                           },
                     exclude: /node_modules/
                     }, {
                     test: /\.css$/,
                     use: ExtractTextPlugin.extract({
                          fallback: &quot;style-loader&quot;,
                          use: [{
                               loader: &quot;css-loader&quot;,
                               options: {
                                  modules: true
                                  }
                               }, {
                               loader: &quot;postcss-loader&quot;
                                  }],
                             })
                          }
                        }
                     ]
                  },
                  plugins: [
                    new webpack.BannerPlugin(&apos;迷途小书童，来打我呀！&apos;)，
                    new HtmlWebpackPlugin({
                        template: _dirname + &quot;/app/index.tmpl.html&quot; //一个插件的实例，并传入相关的参数
                        }),
                    new webpack.optimize.OccurrenceOrderPlugin(),
                    new webpack.optimize.UglifyJsPlugin(),
                    new ExtractTextPlugin(&quot;style.css&quot;)
                    ],
               };
</code></pre><p><strong>解决第一问：</strong><b style="color:#000">什么是WebPack，为什么使用？</b></p>
<p>为什么使用webpack</p><br>&gt;现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出； 很多很好的实践方法<br><br><ul><br><li>模块化，让我们可以把复杂的复杂细化为小的文件</li><br><li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转化为JavaScript文件使浏览器可以识别；</li><br><li>Scss, Less等CSS预处理器</li><br></ul><br>这些改进确实大大提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。<br><p>为什么使用webpack</p><br>&gt;WebPack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss,TypeScript等），并将其转换和打包为适合的格式供浏览器使用。<br><br><p>WebPack和Grunt以及Gulp相比有什么特性</p><br>&gt;其实WebPack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程工具，而WebPack是一种模块化的解决方案，不过WebPack的优点使得WebPack在很多场景下可以代替Gulp/Rrunt类的工具。<br>&gt;<br><br>&gt;Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。<br><br><img src="./1.jpg" alt="Grunt和Gulp的工作流程"><br><p style="color:#ccc; text-align:center; text-decoration: underline">Grunt和Gulp的工作流程</p>

<blockquote>
<p>WebPack的工作方式是：把你的项目当作一个整体，通过一个给定的主文件（如：index.js），WebPack将从这个文件开始找到你的项目所有的依赖文件，使用loader处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>
</blockquote>
<p><img src="./2.png" alt="Webpack工作方式"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">Webpack工作方式</p>

<p><b>如果实在要把两者进行比较，WebPack的处理速度更快更直接，能打包更多不同类型的文件。</b></p>
<p><strong>开始使用WebPack</strong></p>
<p style="color:red">安装</p><br><p> <span style="background:#ccc">WebPack</span> 可以使用 <span style="background:#ccc">npm </span>安装，新建一个空的练习文件夹（此处命名为<span style="background:#ccc"> webpack sample project </span>），在终端中转到该文件夹后执行下述指令就可以完成安装。<br><br>    //全局安装<br>    npm install -g webpack<br>    //安装到你的项目目录<br>    npm install –save-dev webpack<br><br></p><p style="color:red">正式使用WebPack前的准备</p><br>1.在上述练习文件夹中创建一个 <span style="background:#ccc">package.json</span> 文件；这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务。在终端中使用 <span style="background:#ccc"> npm init </span> 命令可以自动创建这个<span style="background:#ccc">package.json</span> 文件<br><br>    npm init<br><br>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，如果不准备在  <span style="background:#ccc"> npm</span> 中发布你的模块，这些问题答案都不重要，回车默认即可。<br><br>2.<span style="background:#ccc"> package.json </span>文件已经就绪，我们在本项目安装 <span style="background:#ccc">WebPack </span> 作为依赖包<br><br>    //安装webpack<br>    npm install –save-dev webpack<br><br>3.回到之前的空文件夹，并在里面创建两个文件夹和<span style="background:#ccc"> public</span> 文件夹，<span style="background:#ccc"> app</span> 文件夹用来存放原始数据和我们将写的 <span style="background:#ccc"> JavaScript</span> 模块，<span style="background:#ccc"> public</span> 文件夹用来存放之后供浏览器读取的文件（包括使用<span style="background:#ccc"> webpack</span> 打包生成的js文件以及一个<span style="background:#ccc"> index.js </span> 文件）。接下来我们再创建三个文件：<br><ol><br>   <li><span style="background:#ccc">index.html</span> ——放在public文件夹中；</li><br>   <li><span style="background:#ccc">Greeter.js</span> ——放在app文件夹中；</li><br>   <li><span style="background:#ccc">main.js</span> ——放在app文件夹中；</li><br></ol><br><br>项目结构图：<br><img src="./3.png" alt="项目结构"><br><p style="color:#ccc; text-align:center; text-decoration: underline">项目结构</p>

<p>我们在<strong>index.html</strong>文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们把打包后的js文件命名为 <span style="background:#ccc">bundle.js</span>）</p>

<pre><code>&lt;!-- index.html --&gt;
&lt;!DOCUTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
   &lt;head&gt;
       &lt;meta charset=&quot;utf-8&quot;&gt;
       &lt;title&gt;WebPack Sample Project&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
       &lt;div id=&apos;root&apos;&gt;&lt;/div&gt;
       &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>我们在 <span style="background:#ccc">Greeter.js</span> 中定义一个返回包含问候信息的 <span style="background:#ccc">html</span> 元素的函数，并依据<span style="background:#ccc">CommonJS</span> 规范导出这个函数为一个模块：</p>

<pre><code>//Greeter.js
module.exports = function(){
   var greet = document.createElement(&apos;div&apos;);
   greet.textContent = &quot;Hi there and greeting!&quot;;
   return greet;
 };
</code></pre><p> <span style="background:#ccc">main.js</span> 文件中我们写入下述代码，用以把 <span style="background:#ccc">Greeter模块</span> 返回的节点插入页面。</p>

<pre><code>//main.js
const greeter = require(&apos;./Greeter.js&apos;);
document.querySelector(&quot;#root&quot;).appendChild(greeter());
</code></pre><p><strong>使用webpack</strong><br>webpack可以在终端中使用，在基本的使用方法如下：</p>
<blockquote>
<h1 id="extry-file-处填写入口文件的路径，本文中就是上述main-js的路径，"><a href="#extry-file-处填写入口文件的路径，本文中就是上述main-js的路径，" class="headerlink" title="{extry  file}处填写入口文件的路径，本文中就是上述main.js的路径，"></a>{extry  file}处填写入口文件的路径，本文中就是上述main.js的路径，</h1><h1 id="destination-for-bundled-file-处填写打包文件的存放路径"><a href="#destination-for-bundled-file-处填写打包文件的存放路径" class="headerlink" title="{destination for bundled file}处填写打包文件的存放路径"></a>{destination for bundled file}处填写打包文件的存放路径</h1><h1 id="填写路径的时候不用添加"><a href="#填写路径的时候不用添加" class="headerlink" title="填写路径的时候不用添加{}"></a>填写路径的时候不用添加{}</h1><p> webpack {enter file} {destination for bundled file}</p>
</blockquote>
<p> 指定入口文件后，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果你的webpack不是全局安装的，那么当你在终端中使用此命令式，需要额外指定其在node_modules中的地址，以上面的例子，在终端中输入如下命令</p>
<pre><code># webpack非全局安装的情况
node_modules/.bin/webpack app/main public/bundle.js
</code></pre><p>结果如下：<br><img src="./4.jpg" alt="使用命令行打包"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">使用命令行打包</p>

<p>可以看出 <span style="background:#ccc">webpack</span> 同时编译了 <span style="background:#ccc">main.js</span> 和 <span style="background:#ccc">Greeter.js</span> ，现在打开 <span style="background:#ccc">index.js</span> ,可以看到如下结果</p><br><img src="./5.png" alt="htmlResult"><br><p style="color:#ccc; text-align:center; text-decoration: underline">htmlResult1</p>

<p>使用 <span style="background:#ccc">webpack</span> 打包一个文件。但在终端进行复杂的操作，其实并不太方便且复杂容易出错，介绍另一种 <span style="background:#ccc">webpack</span> 的常见用法</p>

<p><strong>通过配置文件来使用 <span style="background:#ccc">webpack</span></strong><br><span style="background:#ccc">webpack</span>拥有很多其它的比较高级的功能（比如 <span style="background:#ccc">loaders</span> 和 <span style="background:#ccc">plugins</span>），这些功能其实都可以通过命令行模式实现，但是较容易出错，更好的方法就是配置文件，这个配置文件其实也是一个简单的JavaScript模块，我们可以把所有打包相关的信息放在里面。</p>
<p><title>如何配置？</title></p>
<p>在当前练习文件夹的根目录下新建一个名为 <span style="background:#ccc">webpack.config.js</span> 的文件</p>，我们在其中写入以下配置代码，此配置涉及的内容是入口文件路径和打包文件的存放路径。<br><br>    modules.exports = {<br>      entry: _dirname + “/app/main.js”, //唯一的入口文件<br>      output: {<br>             path: _dirname + “/public”, //打包后存放的地方<br>             filename: “bundle.js” //打包后输出文件的文件名<br>            }<br>         }<br>&gt;<b>注：</b>“_dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。<br><br>有了这个配置之后，再打包文件，只需在终端里运行 <span style="background:#ccc">webpack（非全局安装需使用node_modules/.bin/webpack）</span> 命令就可以了，这条命令会自动引用<span style="background:#ccc">webpack.config.js</span> 文件中的配置选项<br><img src="./6.jpg" alt="配合配置文件进行打包"><br><p style="color:#ccc; text-align:center; text-decoration: underline">配合配置文件进行打包<br></p>

<p><strong>更快捷的执行打包任务</strong><br>在命令行中输入命令需要代码类似于 <span style="background:#ccc">webpack.config.js</span> 这样的路径是比较烦人的，不过值得庆幸的是 <span style="background:#ccc">npm</span> 可以引导任务执行，对  <span style="background:#ccc">npm</span> 进行配置后可以在命令行中使用简单的 <span style="background:#ccc">npm start</span> 命令来代替上面较为繁琐的命令。在 <span style="background:#ccc">package.json</span> 中对 <span style="background:#ccc">scripts</span> 对象进行相关设置即可，设置方法如下：</p>
<pre><code>{
  &quot;name&quot;: &quot;webpack-sample-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Sample webpack project&quot;,
  &quot;scripts&quot;: {
      &quot;start&quot;: &quot;webpack&quot;  //修改的是这里，JSON文件不支持注释，引用时请清除
      },
  &quot;author&quot;: &quot;Tim&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
      &quot;webpack&quot;: &quot;^1.12.9&quot;
       }
   }
</code></pre><blockquote>
<p><b>注：</b> <span style="color:#666">webpack.json</span> 中的 <span style="color:#666">script</span> 会安装一定顺序寻找命令对应位置，本地的<span style="color:#666">node_modules/.bin</span> 路径就在这个寻找清单中，所以无论是全局还是局部安装的WebPack，你都不需要写前面那指明详细的路径了。</p>
</blockquote>
<p>npm的 <span style="background:#ccc">start</span> 命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用 <span style="background:#ccc">npm start</span> 就可以执行其对应的命令，如果对应的此脚本名称不是 <span style="background:#ccc">start</span>，想要在命令行中运行时，需要这样用 <span style="background:#ccc">npm run { script name }</span> 如 <span style="background:#ccc">npm run build</span>，我们在命令行输入 <span style="background:#ccc">npm start</span> 结果如下：<br><img src="./7.jpg" alt="使用 npm 命令打包代码"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">使用npm start 打包代码</p>

<p>现在只需要使用 <span style="background:#ccc">npm start</span> 就可以打包文件了，但要充分发挥其强大的功能我们需要修改配置文件的其他选项。</p>
<p><strong>Webpack的强大功能</strong><br><b>生成Source Maps（使调试更容易）</b></p><p></p>
<p>开发总是离不开调试，方便的调试能极大的提高开发效率，不过有时候通过打包后的文件不容易找到出错的地方，对应的你写的代码的位置，<span style="background:#ccc">Source Maps</span> 就是来帮我们解决这个问题的。</p><br><p>通过简单的配置， <span style="background:#ccc">webpack</span> 就可以为我们自动生成 <span style="background:#ccc">source maps</span>，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。  </p><br><p>在 <span style="background:#ccc">webpack</span> 的配置文件中配置  <span style="background:#ccc">source maps</span>，需要配置 <span style="background:#ccc">devtool</span>，它有以下四种不同的配置选项，各项优缺点描述如下： </p><br><table><br>     <tr><br>          <th>devtool选项</th><br>        <td><span style="background:#ccc">source map</span></td><br>        <td><span style="background:#ccc">cheap-module-source-map</span></td><br>        <td><span style="background:#ccc">eval-source-map</span></td><br>        <td><span style="background:#ccc">cheap-module-eval-source-map</span></td><br>   </tr><br>     <tr><br>          <th>配置结果</th><br>           <td>在一个单独的文件产生一个完整且功能完全的文件。这个文件具有最好的 <span style="background:#ccc">source map</span>，但是它会减慢打包速度。</td><br>              <td>在一个单独的文件产生一个不带列映射的 <span style="background:#ccc">map</span>，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</td><br>             <td>使用 <span style="background:#ccc">eval</span> 打包源文件模块，在同一个文件中生成完整的<span style="background:#ccc">source map</span>，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项</td><br>              <td>这是在打包文件时最快的生成 <span style="background:#ccc">source map</span> 的方法，生成的<span style="background:#ccc">Source Map</span> 会和打包后的 <span style="background:#ccc">JavaScript</span> 文件同行显示，没有列映射，和<span style="background:#ccc">eval-source-map</span> 选项具有相似的缺点</td><br>   </tr><br></table><br><p>正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对打包后的文件的执行有一定影响。</p><br><p>对小到中型的项目中，<span style="background:#ccc">eval-source-map</span> 是一个很好的选项，再次强调你只应该开发阶段使用它，我们继续对上文新建的 <span style="background:#ccc">webpack.config.js</span></p>，进行如下配置：<br><br>    module.exports = {<br>        devtool: ‘eval-source-map’,<br>        entry: _dirname + “/app/index.js”,<br>        output: {<br>          path: _dirname + “/public”,<br>          filename: “bundle.js”<br>          }<br>        }<br><br> &gt;<span style="color:#666">cheap-module-eval-source-map</span> 方法构建速度更快，但不利于调试，推荐在大型项目考虑时间成本时使用。<br><br> <br><strong>使用webpack构建本地服务器</strong><br> &gt;如果想让浏览器监听你的代码的修改，并自动刷新修改后的结果，其实 <span style="background:#ccc">webpack</span> 提供一个可选的本地开发服务器，这个本地服务器基于 <span style="background:#ccc">node.js</span> 构建，可以实现你想要的这些功能，不过他是个单独的组件，在 <span style="background:#ccc">webpack</span> 中进行配置之前需要安装它作为项目依赖<br><br><br>    npm install –save-dev webpack-dev-server<br><br>devServer作为webpack配置选项中的一项，下面是它的一些常见的配置选项<br><table><br>     <tr><br>          <th>devtool配置选项</th><br>        <td><span style="background:#ccc">contentBase</span></td><br>        <td><span style="background:#ccc">port</span></td><br>        <td><span style="background:#ccc">inline</span></td><br>        <td><span style="background:#ccc">historyApiFallback</span></td><br>   </tr><br>     <tr><br>          <th>功能描述</th><br>           <td>默认<span style="background:#ccc">webpack-dev-server</span>，会为根文件夹提供本地服务器，如果想为另外一个目录文件提供本地服务器，应该在这里设置其所在目录（本例设置到”public”目录）</td><br>              <td>设置默认监听端口，如果省略，默认为”8080”</td><br>             <td>设置为 <span style="background:#ccc">true</span> 当源文件改变时会自动刷新页面</td><br>              <td>在开发单页应用时非常有用，它依赖于<span style="background:#ccc">HTML5 history API</span>，如果设置为<span style="background:#ccc">true</span>，所有的跳转都会指向index.html  </td><br>   </tr><br></table><br><br><p>把这些命令加到webpack的配置文件中，现在的配置文件 <span style="background:#ccc">webpack.config.js</span> 如下所示</p>

<pre><code>module.exports = {
   devtool: &apos;eval-source-map&apos;,

   enter: _dirname + &quot;/app/main.js&quot;,
   output: {
     path: _dirname + &quot;/public&quot;,
     filename: &apos;bundle.js&apos;
     },

    devServer: {
      contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
      historyApiFallback: true, //不跳转
      inline： true  //实时刷新
      }  
   }
</code></pre><p>在 <span style="background:#ccc">package.json</span> 中的 <span style="background:#ccc">script</span> 对象中添加如下命令，用以开启本地服务器：</p>

<pre><code>&quot;script&quot;: {
   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
   &quot;start&quot;: &quot;webpack&quot;,
   &quot;server&quot;: &quot;webpack-dev-server --open&quot;
 },
</code></pre><p> 在终端中输入 <span style="background:#ccc">npm run server</span> 即可在本地的 <span style="background:#ccc">8080</span> 端口查看结果</p>


<p><img src="./9.jpg" alt="开启本地服务器"></p>
<p style="color:#ccc; text-align:center; text-decoration: underline">开启本地服务器</p>

<p><strong>Loaders</strong></p>
<p><span style="background:#ccc">Loaders</span> 是 <span style="background:#ccc">webpack</span> 提供的最激动地功能。通过不同的<span style="background:#ccc">loader</span>，<span style="background:#ccc">webpack</span> 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换SCSS为CSS，或者把下一代的JS文件（ES6，ES7）转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React中用到的JSX文件转化成JS文件。</p><br>Loaders需要单独安装并且需要在<span style="background:#ccc">webpack。config.js</span> 中的 <span style="background:#ccc">modules</span> 关键字下进行配置，Loaders的配置包括以下几个方面：<br><ul><br>        <li><span style="background:#ccc">test</span>：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><br>        <li><span style="background:#ccc">loader</span> : loader的名称（必须） </li><br>         <li><span style="background:#ccc">include/exclude</span> :  手动添加必须处理的文件（文件夹）或屏蔽不需要的文件（文件夹）（可选）；</li><br>         <li><span style="background:#ccc">query</span> ： 为loaders提供额外的设置选项（可选）</li><br></ul><br><br><p>不过在配置loader之前，我们把 <span style="background:#ccc">Greeter.js</span> 里的问候消息放在一个单独的JSON文件里，并通过合适的配置使<span style="background:#ccc">Greeter.js</span> 可以读取该JSON文件的值，各文件的代码如下：</p><br><p>在app文件夹中创建带有问候信息的JSON文件（命名为<span style="background:#ccc">config.js</span>）</p>

<pre><code>{
  &quot;greetText&quot;: &quot;Hi there and greetings from JSON&quot;
}
</code></pre><p>更新后的Greeter.js</p>

<pre><code>var config = require(&apos;./config.json&apos;);

module.exports = function(){
  var greet = document.createElement(&apos;div&apos;);
  greet.textContent = config.greetText;
  return greet;
};
</code></pre><blockquote>
<p><strong>注：</strong>由于 <span style="color:#666">webpack3. / webpack2.</span>已经内置可处理JSON文件，这里我们无需再添加 <span style="color:#666">webpack1.</span> 需要的 <span style="color:#666">json-loader</span></p>
</blockquote>
<p><strong>Bable</strong></p>
<p>Babel其实是一个编译JavaScript的平台，它的强大之处表现于可以通过编译帮你达到以下目的：</p><br><br><ul><br>  <li>使用下一代的JavaScript代码（ES6，ES7…），即使这些标准目前并未被当前的浏览器完全的支持；</li><br>  <li>使用基于JavaScript进行了拓展的语言，比如React的JSX；</li><br></ul><br><br><strong>Bable的安装与配置</strong><br><p>Babel其实是几个模块化的包，其核心功能位于 <span style="background:#ccc">babel-core</span> 的npm包中，</p>webpack可以把其不同的包整合在一起使用，对于每个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的 <span style="background:#ccc">babel-preset-es2015</span> 包和解析JSX的 <span style="background:#ccc">babel-preset-react</span> 包）。<br><br><p>一次性安装依赖包</p>

<pre><code>// npm一次性安装多个依赖模块，模块与模块之间用空格隔开
npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react
</code></pre><p>在 <span style="background:#ccc">webpack</span> 中配置Babel的方法：</p>
<pre><code>module.exports = {
    entry: _dirname + &quot;/app/main.js&quot;, //已经多次提及的唯一入口文件
    output: {
       path: _dirname + &quot;public&quot;, //打包后的文件存放的地方
       filename： &quot;bundle.js&quot; //打包后输出文件的文件名
       }，
   devtool: &apos;eval-source-map&apos;,
   devServer: {
      contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
      historyApiFallback: true, //不跳转
      inline: true //实时刷新
     },
   module: {
      rules: [
        {
           test: /(\.jsx|\.js)$/,
           use: {
                loader: &quot;babel-loader&quot;,
                option: {
                   preset: [
                       &quot;es2015&quot;: &quot;react&quot;
                       ]
                     }
                   },
           exclude: /node_modules/
         }
       ]
     }
  };
</code></pre><p>配置webpack以后就已经允许使用ES6以及JSX的语法了。继续使用上面的例子进行测试，不过这次会使用React，先安装React和React-DOM</p>

<pre><code>npm install --save react react-dom
</code></pre><p>接下来我们使用ES6的语法，更新 <span style="background:#ccc">Greeter.js</span> 并返回一个React组件 </p>

<pre><code>//Greeter.js
import React, {Component} from &apos;react&apos;
import config from &apos;./config.json&apos;;

class Greeter extents Component{
   render() {
      return (
         &lt;div&gt;
           {config.greetText}
         &lt;/div&gt;  
       );
     }
  }

export default Greeter
</code></pre><p>修改 <span style="background:#ccc">mian.js</span> 如下，使用ES6模块定义和渲染Greeter模块</p>

<pre><code>//main.js
import React from &apos;react&apos;;
import {render} from &apos;react-dom&apos;;
import Greeter from &apos;./Greeter&apos;;

render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;));
</code></pre><p>重新使用npm start</p> 打包，如果之前打开的本地服务器没有关闭，你应该可以在<span style="background:#ccc">localhost:8080</span> 下看到与之前一样的内容，这说明 <span style="background:#ccc">react</span> 和  <span style="background:#ccc">es6</span> 被正常打包了。<br><img src="./11.jpg" alt="localhost:8080"><br><p style="color:#ccc; text-align:center; text-decoration: underline">localhost:8080</p>

<p><strong>Babel的配置</strong></p>
<p>Babel其实可以完全在 <span style="background:#ccc">webpack.config.js</span> 文件中进行配置，但是考虑到babel具有非常多的配置选项，在单一的 <span style="background:#ccc"> webpack.config.js</span> 文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 <span style="color:#f60">“.babelrc”</span> 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们就会提取 出相关部分，分两个配置文件进行配置（webpack会自动调用 <span style="background:#ccc">.babelrc</span> 里的babel配置选项），如下：<br><br>    module.exports = {<br>       entry: _dirname + “/app/main.js”, //已多次提及的唯一入口文件<br>       output: {<br>          path: _dirname + “/public”, //打包后的文件存放的地方<br>          filename: “bundle.js” //打包后输出的文件的文件名<br>          },<br>       devtool: ‘eval-source-map’,<br>       devSaver: {<br>          contentBase: “./public”, //本地服务器所加载的页面所在的目录<br>          historyApiFallback: true, //不跳转<br>          inline: true //实时刷新<br>        },<br>       module: {<br>          rules: [<br>            {<br>               test: /(.jsx|.js)$/,<br>               use: {<br>                   loader: “babel-loader”<br>                  },<br>               exclude: /node_modules/<br>            }<br>          ]<br>        }<br>      };<br><br><br><br><br>    //.babelrc<br>    {<br>      “presets”: [“react”, “es2015”]<br>    }<br><br><br><b>一切皆模块</b><br> </p><p> Webpack有一个不可不说的优点，它把所有的文件都当做模块处理，JavaScript代码，CSS和fonts以及图片等等通过合适的loader都可以被处理。<br><br><b>CSS</b><br></p><p>webpack提供两个工具处理表，<span style="background:#ccc">css-loader</span> 和 <span style="background:#ccc">style-loader</span>，两者处理的任务不同，<span style="background:#ccc">css-loader</span>  使你能够使用类似 <span style="background:#ccc">@import</span> 和<span style="background:#ccc">url(…)</span> 的方法实现 <span style="background:#ccc">require()</span> 的功能，<span style="background:#ccc">style-loader</span> 将所有的计算后的样式加入页面中，两者组合在一起使你能够把样式便嵌入webpack打包后的JS文件中。<br><br>    //安装<br>    npm install –save-dev style-loader css-loader<br><br><br><br><br>    //使用<br>    module。exports = {<br>      …<br>       module: {<br>           rules: [<br>                {<br>                  test: /(.jsx|.js)$/,<br>                  use: {<br>                     loader: “babel-loader”<br>                   },<br>                  exclude: /node_modules/<br>                },<br>                {<br>                  test: /.css$/,<br>                  use: [<br>                    {<br>                       loader: “style-loader”<br>                    },<br>                    {<br>                       loader: “css-loader”<br>                    }<br>                  ]<br>                }<br>               ]<br>             }<br>           };<br><br><br>&gt;注意这里对同一个文件引入多个loader的方法<br><br></p><p>接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式</p><br><br>    /<em> main.css </em>/<br>    html {<br>      box-sizing: border-box;<br>      -ms-text-size-adjust: 100%;<br>      -webkit-text-size-adjust: 100%;<br>    }<br><br>    <em>, </em>:before, *:after {<br>      box-sizing: inherit;<br>    }<br><br>    body {<br>      margin: 0;<br>      font-family: ‘Helvetica Neue’, Helvetica, Arial, sans-serif;<br>    }<br><br>    h1, h2, h3, h4, h5, h6, p, ul {<br>      margin: 0;<br>      padding: 0;<br>    }<br><br>我们这里例子中用到的 <span style="background:#ccc">webpack</span> 只有单一的入口， 其它的模块需要通过 <span style="background:#ccc">import</span>，<span style="background:#ccc">require</span> ，<span style="background:#ccc">url</span> 等与入口文件建立其关联，为了让webpack能找到”main.css”文件，我们把它导入”main.js”中，如下<br><br>    //main.js<br>    import React from ‘react’;<br>    import {render} from ‘react-dom’;<br>    import Greeter from ‘./Greeter’;<br><br>    import ‘./main.css’; //使用require导入css文件<br><br>    render(<greeter>, document.getElementById(‘root’));<br><br>&gt;通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独文件的。<br><br><br>上面的代码说明webpack是怎么把css当作模板看待的，咱们继续看一个更加真实的css模块实践。<br><br><b>CSS module </b><br><br><br><a>在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，配合优化工具，依赖管理和加载管理可以自动化完成。</a><br><p>不过前端的另外一部分，CSS发展就相对于来说慢一些，大多的样式表却依旧巨大且充满了全局类名，维护和修改都非常困难。<br></p><p style="color : #f60;">CSS module的技术就意在把JS的模块化思想带入到CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules”传递到所需要的地方，然后就可以直接把CSS的类名传递到组件代码中，且这样做只对当前组件有效，不必担心在不同的模块中使用相同的类名造成冲突。具体代码如下：<br><br>    module.exports = {<br>       …<br><br>       module: {<br>           rules: [<br>             {<br>                test: /(.jsx|.js)$/,<br>                use: {<br>                   loader: “babel-loader”<br>                  },<br>                exclude: /node_modules/<br>             },<br>             {<br>                test: /.css$/,<br>                use: [<br>                     {<br>                        loader: “style-loader”<br>                     },{<br>                        loader: “css-loader”,<br>                        options: {<br>                            modules: true<br>                          }<br>                        }<br>                      ]<br>                    }<br>                  ]<br>                }<br>              };<br>在app文件夹下创建一个 <span style="background:#ccc">Greeter.css</span> 文件<br><br>    .root {<br>       background-color: #eee;<br>       padding: 10px;<br>       barder: 3px solid #ccc;<br>     }<br>导入 <span style="background:#ccc">.root</span> 到Greeter.js中<br><br>    import React, {component} from ‘react’;<br>    import config from ‘./config.json’;<br>    import styles from ‘./Greeter.css’; //导入<br><br>    class Greeter extends Component{<br>      render() {<br>         return(<br>           <div classname="{styles.root}"> //添加类名<br>             {config.greetText}<br>           </div><br>          );<br>        }<br>      }<br><br>     export default Greeter<br></p><p>即使相同类名也不会造成污染<br><br><img src="./15.jpg" alt="应用了css module后的样式"><br></p><p style="color:#ccc; text-align:center; text-decoration: underline">应用了css module后的样式</p>

<p><b>CSS 预处理器</b><br><span style="background:#ccc">Sass</span> 和 <span style="background:#ccc">Less</span> 之类的预处理器是对原生CSS进行拓展，它们允许你使用类似于 <span style="background:#ccc">variables</span>，<span style="background:#ccc">nesting</span>，<span style="background:#ccc">mixins</span>，<span style="background:#ccc">inheritance</span>等不存在于CSS中的特性来写CSS，CSS预处理器可以使得这些特殊类型的语句转化为浏览器可识别的CSS语句。在webpack里使用相关的loaders进行配置就可以使用了，以下是常见的CSS处理 <span style="background:#ccc">loaders</span> :</p>
<p><ul><br>    <li style="color:#ccc">Less Loader</li><br>    <li style="color:#ccc">Sass Loader</li><br>    <li style="color:#ccc">Stylus Loader</li><br></ul><br><a>不过也存在一个CSS的处理平台 <span style="background:#ccc">PostCSS</span> 使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。</a></p>
<p>安装 <span style="background:#ccc">postcss-loader</span> 和 <span style="background:#ccc">autoprefixer(自动添加前缀的插件)</span></p>

<pre><code>npm install --save-dev postcss-loader autoprefixer
</code></pre><p>接下来，在webpack配置文件中添加<span style="background:#ccc">postcss-loader</span>，在根目录新建<span style="background:#ccc">postcss.config.js</span>，并添加如下代码之后，重新使用<span style="background:#ccc">npm start</span> 打包时，你写的css会自动添加不同前缀。</p>
<pre><code>//webpack.config.js
module.exports = {
  ...
  module: {
    rules: [
       {
          test: /(\.jsx|\.js)$/,
          use: {
              loader: &quot;babel-loader&quot;
          },
          exclude: /node_modules/
       },
       {
          test: /(\.css$/),
          use: [
             {
               loader: &quot;style-loader&quot;
             },{
               loader: &quot;css-loader&quot;,
               options: {
                   modules: true
                  }
             },{
               loader: &quot;postcss-loader&quot;
             }
           ]
         }
       ]
     }
   }
</code></pre><p>  <br></p>
<pre><code>//postcss.config.js
module.exports = {
  plugins: [
     require(&apos;autoprefixer&apos;)
   ]
 }
</code></pre><p>上述已经谈论了处理JS的Babel和处理CSS的PostCSS的基本用法，它们其实也是两个独立的平台，配合 <span style="background:#ccc">webpack</span> 可以很好的发挥它们的作用。</p>
<p><b>插件（plugins）</b><br><a>插件(plugins)是用来拓展Webpack功能的，他们在整个构建过程中生效，执行相关任务。</a><br><a>Loaders和plugins常常被弄混，但是它们其实是完全不同的东西，可以这么说：loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less…），一次处理一个，插件并不直接操作单个文件，它直接对着整个构建过程起作用。</a></p>
<p>Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>

<p><b>使用插件的方法</b></p>
<p>要使用某个插件，我们需要通过 <span style="background:#ccc">npm</span> 安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组），我们给打包后代码  <a href="https://webpack.js.org/plugins/banner-plugin/" target="_blank" rel="external">添加版权声明的插件</a>。<br><br>    const webpack = require(‘webpack’);<br>    module.exports = {<br>       …<br>          module: {<br>               rules: [<br>                   {<br>                      test: /(.jsx|.js)$/,<br>                      use: {<br>                        loader: “babel-loader”<br>                        },<br>                      exclude: /node_modules/<br>                   },<br>                   {<br>                      test: /.css$/,<br>                      use: [<br>                         {<br>                           loader: “style-loader”<br>                           options:{<br>                                modules: true<br>                               }<br>                          },<br>                          {<br>                            loader: “postcss-loader”<br>                          }<br>                        ]<br>                      }<br>                    ]<br>                  },<br>                  plugins: [<br>                     new webpack.bannerPlugin(‘版权所有，翻版必究’)<br>                   ],<br>                 };<br><br><br>通过这个插件，打包后的JS文件显示如下<br>   <img src="./16.jpg" alt="版权所有，翻版必究"><br>   </p><p style="color:#ccc; text-align:center; text-decoration: underline">版权所有，翻版必究</p>

<p><strong>常见的插件</strong></p>
<h5>HtmlWebpackPlugin</h5><br><p>这个插件的主要作用是依据一个简单的 <span style="background:#ccc">index.html</span> 模板，生成一个自动引用你打包后的JS文件的新 <span style="background:#ccc">index.html</span>。这在每次生成的JS文件名不同时非常有用（比如添加了 <span style="background:#ccc">hash</span> 值）。</p><br><h5>安装</h5>

<pre><code>npm install --save-dev html-webpack-plugin
</code></pre><p>这个插件自动完成了我们之前手动作的一些事情，在正式使用之前需要对一直以来的项目结构做一些更改：</p><br><ol><br>     <li>移除public文件夹，利用此插件， <span style="background:#ccc">index.html</span> 文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。</li><br>      <li>在app目录下，创建一个 <span style="background:#ccc">index.tmpl.html</span> 文件模板，这个模板包含<span style="background:#ccc">title</span> 等必须元素，在编译过程中，插件会依据此模板生成最终的html页面，会自动添加所以来的css，js，favicon等文件，<span style="background:#ccc">index.tmpl.html</span> 中的模板源代码如下：</li><br></ol><br><br>    &lt;!DOCTYPE html&gt;<br>    <html lang="en"><br>      <head><br>         <meta charset="utf-8"><br>         <title>Webpack Sample Project</title><br>      </head><br>      <body><br>         <div id="root"></div><br>      </body><br>    </html><br><br><p>3. 更新 <span style="background:#ccc">webpack</span> 的配置文件，方法同上，新建一个 <span style="background:#ccc">build</span> 文件夹用来存放最终的输出文件</p>

<pre><code>const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
  entry: _dirname + &quot;./app/main.js&quot;  //唯一入口文件
  output: {
     path: _dirname + &quot;/build&quot;,
     filname: &quot;bundle.js&quot;
   },
   devtool: &apos;evel-source-map&apos;,
   devServer: {
      contentBase: &quot;./public&quot;,  //本地服务器所加载的页面所在的目录
      historyApiFallback: true,  //不跳转
      inline: true  //实时刷新
    },
  module: {
      rules: [
          {
             test: /(\.jsx|\.js)$/,
             use: {
                loader: &quot;babel-loader&quot;
               },
                exclude: /node_modules/
          },
          {
             test: /\.csss$/,
             use: [
                 {
                   loader: &quot;style-loader&quot;
                 },{
                   loader: &quot;css-loader&quot;,
                   options: {
                      modules: true
                     }
                  },{
                   loader: &quot;postcss-loader&quot;
                  }
                ]
              }
            ]
          },
          plugins: [
             new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
             new HtmlWebpackPlugin({
                 template: _dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数
                 })
               ],
           };
</code></pre><p>再次执行 <span style="background:#ccc">npm start</span> 你会发现，build文件夹下面生成了 <span style="background:#ccc">bundle.js</span>  和  <span style="background:#ccc">index.html</span> 。<br><img src="./14.png" alt="build文件夹"><br> </p><p style="color:#ccc; text-align:center; text-decoration: underline">build 文件夹</p><p></p>
<p></p><h5>Hot Module Replacement</h5><p></p>
<p><span style="background:#ccc">Hot Module Replacement</span> (HMR) 也是webpack里很有用的插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。</p><br><p>在webpack中实现HMR也很简单，只需要做两项配置<br><ol><br>  <li>在webpack配置文件中添加HMR插件；</li><br>   <li>在Webpack Dev Server中添加”hot”参数；</li><br></ol><br></p><br><p>不过配置完这些后，JS模块其实还不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。</p><br><p>实现方法如下</p><br> <ul><br>       <li><span style="background:#ccc">Babel</span> 和 <span style="background:#ccc">webpack</span> 是独立的工具</li><br>       <li>两者可以一起工作</li><br>       <li>两者可以通过插件拓展功能</li><br>       <li>HMR是一个webpack插件，它让你能在浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配置</li><br>     <li>Babel有一个叫做 <span style="background:#ccc">react-transform-hrm</span> 的插件，可以在不对React模块进行额外配置的前提下让HMR正常工作；</li><br>      </ul><br><p>如何进行额外的配置</p>

<pre><code>const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
   entry: _dirname + &quot;/app/main.js&quot;, //唯一入口文件
   output: {
      path: _dirname + &quot;/build&quot;,
      filename: &quot;bundle.js&quot;
    },
    devtool: &apos;eval-source-map&apos;,
    devServer: {
      contentBase: &quot;./public&quot;, //本地服务器所加载页面所在的目录
      historyApiFallback: true, //不跳转
      inline: true,
      hot: true
    },
    module: {
      rules: [
         {
             test: /(\.jsx|\.js)$/,
             use: {
                 loader: &quot;babel-loader&quot;
                },
             exclude: /node_modules/
         },
         {
             test:/\.css$/,
             use: [
              {
                 loader: &quot;style-loader&quot;
              },
              {
                 loader: &quot;css-loader&quot;,
                 options:{
                     modules: true
                    }
              },
              {
                 loader: &quot;postcss-loader&quot;
              }
            ]
          }
        ]
      },
      plugins: [
         new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),
         new HtmlWebpackPlugin({
              template: _dirname + &quot;/app/index.tmpl.html&quot; //插件实例，并传入相关参数
              }),
         new webpack.HotModuleReplacementPlugin()  //热加载插件
       ],
    };
</code></pre><p>安装 <span style="background:#ccc">react-transform-hmr</span></p>

<pre><code>npm install --save-dev babel-plugin-react-transform react-transform-hmr
</code></pre><p></p><p>配置Babel</p>
<pre><code>// .babelrc
{
  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;],
  &quot;env&quot;: {
     &quot;development&quot;: {
        &quot;plugins&quot;: [[&quot;react-transform&quot;,{
               &quot;transforms&quot;: [{
                    &quot;transform&quot;: &quot;react-transform-hmr&quot;,
                    &quot;imports&quot;: [&quot;react&quot;],
                    &quot;locals&quot;: [&quot;module&quot;]
                  }]
                }]]
              }
            }
          }
</code></pre><p> 现在当你使用React时，可以热加载模块了，每次保存就能在浏览器上看到更新内容。<br> </p><h5>产品阶段的构建</h5><p></p>
<p></p><p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如优化，压缩，缓存，以及分离CSS和JS。</p>
<p></p><p>对于复杂的项目来说，需要复杂的配置，这时分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个 <span style="background:#ccc">webpack.production.config.js</span> 的文件，在里面加上基本的配置，它和原始的webpack.config.js很像，如下：</p>
<pre><code>//webpack.production.config.js
const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
    entry: _dirname + &quot;/app/main.js&quot; //唯一的入口文件
    output: {
       path: _dirname + &quot;/build&quot;,
       filename: &quot;bundle.js&quot;
     },
    devtool: &apos;eval-source-map&apos;,
    devServer: {
        contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录
        historyApiFallback: true, //不跳转
        inline: true, 
        hot: true
      },
      module: {
         rules: [{
            test: /()\.jsx|\.js}$/,
            use: {
               loader: &quot;babel-loader&quot;
              },
            exclude: /node_modules/
         ],{
            test: /\.css$/,
            use: ExtractTextPlugin.extract({
                  fallback: &quot;style-loader&quot;,
                  use: [{
                       loader: &quot;css-loader&quot;,
                       options: {
                           modles: true
                        }
                     },{
                       loader: &quot;postcss-loader&quot;
                     }],
                  })
                }]
             },
             plugins: [
               new webpack.BannerPlugin(&quot;版权所有，翻版必究&quot;),
               new HtmlWebpackPlugin({
                   template: _dirname + &quot;/app/index.tmpl.html&quot; //new一个插件的实例，并传入相关的参数
                   }),
               new webpack.HotModuleRepalacementPlugin()  //热加载插件     
               ],
           };
</code></pre><p><br></p>
<pre><code>//package.json
{
  &quot;name&quot;: &quot;test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;script&quot;: {
      &quot;test&quot;: &quot;echo \&quot;Error: no test specifie\&quot; &amp;&amp; exit 1&quot;,
      &quot;start&quot;: &quot;webpack&quot;,
      &quot;server&quot;: &quot;webpack-dev-server --open&quot;,
      &quot;build&quot;: &quot;NODE_ENV=production webpack --config ./webpack.production.config.js --progress&quot;
      },
      &quot;author&quot;: &quot;&quot;,
      &quot;license&quot;: &quot;ISC&quot;,
      &quot;devDependencies&quot;: {
      ...
      },
      &quot;dependencies&quot;: {
         &quot;react&quot;: &quot;^15.6.1&quot;,
         &quot;react-dom&quot;: &quot;^15.6.1&quot;
        }
      }
</code></pre></greeter>
  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack工程实践总结"><span class="toc-text">webpack工程实践总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#extry-file-处填写入口文件的路径，本文中就是上述main-js的路径，"><span class="toc-text">{extry  file}处填写入口文件的路径，本文中就是上述main.js的路径，</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#destination-for-bundled-file-处填写打包文件的存放路径"><span class="toc-text">{destination for bundled file}处填写打包文件的存放路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#填写路径的时候不用添加"><span class="toc-text">填写路径的时候不用添加{}</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined"><span class="toc-text">HtmlWebpackPlugin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined"><span class="toc-text">Hot Module Replacement</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined"><span class="toc-text">产品阶段的构建</span></a></li></ol></li></ol></li></ol></li></ol>
  </div>
</div>

  
<nav id="pagination">
  

  

  
    <a href="/在vue事件处理中注意的问题/" class="next">下一篇 在vue事件处理中注意的问题 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Tim-ao using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>



<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/images/avatar.jpg">
    <p id="description">下一次,世界精彩处见！</p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://www.douban.com/people/102386480/">
        
          <i class="icon iconfont douban">&#xe60f;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.facebook.com/ao.zhiqiang">
        
          <i class="icon iconfont facebook">&#xe604;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://weibo.com/5310594076/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1">
        
          <i class="icon iconfont weibo">&#xe602;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://github.com/apacheao">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://www.ftchinese.com/users/mystories">
        
          <i class="icon iconfont rss">&#xe60e;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

